#!/usr/bin/env python3
"""
ANALYSEUR ANTAGONISMES √âMOTIONNELS AVANC√â
========================================

D√©tection automatique des antagonismes implicites bas√©e sur la neurobiologie,
la ph√©nom√©nologie et la logique compositionnelle des √©motions Panksepp.
"""

import json
import time
from typing import Dict, List, Any, Tuple
from dataclasses import dataclass

@dataclass
class AntagonismAnalysis:
    """Analyse d√©taill√©e d'un antagonisme √©motionnel"""
    dhatu_pair: Tuple[str, str]
    antagonism_strength: float
    neurobiological_conflict: str
    phenomenological_evidence: str
    composability_impact: str
    resolution_mechanisms: List[str]
    real_world_examples: List[str]

class AdvancedEmotionalAntagonismAnalyzer:
    """Analyseur avanc√© des antagonismes √©motionnels"""
    
    def __init__(self):
        self.panksepp_systems = ['SEEK', 'RAGE', 'FEAR', 'LUST', 'CARE', 'GRIEF', 'PLAY']
        self.neurobiological_circuits = self._define_neural_circuits()
        self.phenomenological_oppositions = self._define_phenomenological_oppositions()
        
    def _define_neural_circuits(self) -> Dict[str, Dict[str, Any]]:
        """D√©finit circuits neurobiologiques de chaque syst√®me Panksepp"""
        
        return {
            'SEEK': {
                'primary_circuits': ['VTA', 'Nucleus Accumbens', 'Cortex Pr√©frontal'],
                'neurotransmitters': ['Dopamine'],
                'activation_pattern': 'Approche, exploration, motivation',
                'inhibited_by': ['Stress √©lev√©', 'Peur intense', 'D√©pression'],
                'competes_with': ['Syst√®mes √©vitement']
            },
            'RAGE': {
                'primary_circuits': ['Amygdale', 'Hypothalamus', 'PAG'],
                'neurotransmitters': ['Noradr√©naline', 'Testost√©rone'],
                'activation_pattern': 'Attack, domination, destruction',
                'inhibited_by': ['Ocytocine √©lev√©e', 'S√©rotonine'],
                'competes_with': ['Syst√®mes affiliation']
            },
            'FEAR': {
                'primary_circuits': ['Amygdale', 'Hippocampe', 'Locus Coeruleus'],
                'neurotransmitters': ['Noradr√©naline', 'GABA d√©ficit'],
                'activation_pattern': '√âvitement, freeze, fuite',
                'inhibited_by': ['GABA', 'Opio√Ødes'],
                'competes_with': ['Syst√®mes approche']
            },
            'LUST': {
                'primary_circuits': ['Hypothalamus', 'Aire pr√©optique'],
                'neurotransmitters': ['Testost√©rone', '≈ístrog√®nes', 'Dopamine'],
                'activation_pattern': 'Recherche sexuelle, copulation',
                'inhibited_by': ['Cortisol', 'Prolactine', 'Stress'],
                'competes_with': ['Syst√®mes stress']
            },
            'CARE': {
                'primary_circuits': ['Cortex cingulaire', 'Aire pr√©optique'],
                'neurotransmitters': ['Ocytocine', 'Vasopressine', 'Opio√Ødes'],
                'activation_pattern': 'Protection, nurturing, empathie',
                'inhibited_by': ['Stress chronique', 'Testost√©rone √©lev√©e'],
                'competes_with': ['Syst√®mes agression']
            },
            'GRIEF': {
                'primary_circuits': ['Cingulaire ant√©rieur', 'Syst√®me opio√Øde'],
                'neurotransmitters': ['Opio√Ødes endog√®nes', 'Cortisol'],
                'activation_pattern': 'D√©tresse s√©paration, pleurs',
                'inhibited_by': ['Ocytocine', 'Dopamine'],
                'competes_with': ['Syst√®mes r√©compense']
            },
            'PLAY': {
                'primary_circuits': ['Cortex pr√©frontal', 'Syst√®me cannabino√Øde'],
                'neurotransmitters': ['Anandamide', 'Dopamine'],
                'activation_pattern': 'Jeu social, exploration joyeuse',
                'inhibited_by': ['Cortisol', 'Stress'],
                'competes_with': ['Syst√®mes stress/survie']
            }
        }
    
    def _define_phenomenological_oppositions(self) -> List[Dict[str, Any]]:
        """D√©finit oppositions ph√©nom√©nologiques document√©es"""
        
        return [
            {
                'pair': ('RAGE', 'CARE'),
                'opposition_type': 'Motivational',
                'description': 'Destruction vs construction, agression vs protection',
                'intensity_dependency': True,
                'temporal_resolution': 'Possible alternance rapide',
                'examples': ['Parent prot√®ge enfant (CARE) puis attaque agresseur (RAGE)'],
                'phenomenology': 'Tensions entre impulse destructeur et protecteur'
            },
            {
                'pair': ('FEAR', 'SEEK'),
                'opposition_type': 'Behavioral',
                'description': '√âvitement vs approche, retrait vs exploration', 
                'intensity_dependency': True,
                'temporal_resolution': 'Alternance lente n√©cessaire',
                'examples': ['Phobie bloque curiosit√©', 'Anxi√©t√© paralyse apprentissage'],
                'phenomenology': 'Conflit approche-√©vitement classique'
            },
            {
                'pair': ('GRIEF', 'PLAY'),
                'opposition_type': 'Affective',
                'description': 'Douleur vs plaisir, fermeture vs ouverture',
                'intensity_dependency': True,
                'temporal_resolution': 'Transition graduelle possible',
                'examples': ['Deuil emp√™che jeu spontan√©', 'D√©pression = absence PLAY'],
                'phenomenology': 'Incompatibilit√© tonale √©motionnelle'
            },
            {
                'pair': ('GRIEF', 'LUST'),
                'opposition_type': 'Physiological',
                'description': 'Stress vs reproduction, fermeture vs ouverture',
                'intensity_dependency': False,
                'temporal_resolution': 'R√©cup√©ration lente n√©cessaire',
                'examples': ['Deuil conjugal', 'D√©pression sexuelle'],
                'phenomenology': 'Incompatibilit√© √©nerg√©tique fondamentale'
            },
            {
                'pair': ('RAGE', 'GRIEF'),
                'opposition_type': 'Energetic',
                'description': 'Externalisation vs internalisation, action vs passivit√©',
                'intensity_dependency': True,
                'temporal_resolution': 'Alternance possible',
                'examples': ['Col√®re masque chagrin', 'Basculement rage‚Üítristesse'],
                'phenomenology': 'Diff√©rence direction √©nergie √©motionnelle'
            }
        ]
    
    def analyze_implicit_antagonisms(self) -> Dict[str, Any]:
        """Analyse tous les antagonismes implicites possibles"""
        
        print("üîç ANALYSE ANTAGONISMES √âMOTIONNELS AVANC√âE")
        print("=" * 45)
        
        results = {
            'timestamp': time.strftime('%Y-%m-%dT%H:%M:%SZ'),
            'analysis_type': 'Advanced Emotional Antagonism Detection',
            'detected_antagonisms': [],
            'neurobiological_conflicts': [],
            'phenomenological_conflicts': [],
            'composability_warnings': [],
            'resolution_strategies': {}
        }
        
        # Analyse toutes paires possibles
        for i, dhatu1 in enumerate(self.panksepp_systems):
            for dhatu2 in self.panksepp_systems[i+1:]:
                
                antagonism = self._analyze_pair_antagonism(dhatu1, dhatu2)
                
                if antagonism.antagonism_strength > 0.3:  # Seuil significatif
                    results['detected_antagonisms'].append({
                        'pair': antagonism.dhatu_pair,
                        'strength': antagonism.antagonism_strength,
                        'neurobiological_conflict': antagonism.neurobiological_conflict,
                        'phenomenological_evidence': antagonism.phenomenological_evidence,
                        'composability_impact': antagonism.composability_impact,
                        'resolution_mechanisms': antagonism.resolution_mechanisms,
                        'real_world_examples': antagonism.real_world_examples
                    })
                    
                    print(f"‚ö†Ô∏è {dhatu1} ‚Üî {dhatu2}: {antagonism.antagonism_strength:.3f}")
                    print(f"   üí≠ {antagonism.phenomenological_evidence}")
                    
        print(f"\nüìä {len(results['detected_antagonisms'])} antagonismes d√©tect√©s")
        
        # Classification par force
        strong_antagonisms = [a for a in results['detected_antagonisms'] if a['strength'] > 0.7]
        moderate_antagonisms = [a for a in results['detected_antagonisms'] if 0.5 < a['strength'] <= 0.7]
        weak_antagonisms = [a for a in results['detected_antagonisms'] if 0.3 < a['strength'] <= 0.5]
        
        results['classification'] = {
            'strong_antagonisms': len(strong_antagonisms),
            'moderate_antagonisms': len(moderate_antagonisms),
            'weak_antagonisms': len(weak_antagonisms)
        }
        
        # G√©n√©ration strat√©gies r√©solution
        results['resolution_strategies'] = self._generate_resolution_strategies(results['detected_antagonisms'])
        
        return results
    
    def _analyze_pair_antagonism(self, dhatu1: str, dhatu2: str) -> AntagonismAnalysis:
        """Analyse antagonisme pour une paire sp√©cifique"""
        
        circuit1 = self.neurobiological_circuits[dhatu1]
        circuit2 = self.neurobiological_circuits[dhatu2]
        
        # 1. Conflit neurobiologique
        neuro_conflict_score = self._calculate_neurobiological_conflict(circuit1, circuit2)
        neuro_conflict_desc = self._describe_neurobiological_conflict(dhatu1, dhatu2, circuit1, circuit2)
        
        # 2. Opposition ph√©nom√©nologique
        phenom_conflict_score = self._calculate_phenomenological_conflict(dhatu1, dhatu2)
        phenom_evidence = self._get_phenomenological_evidence(dhatu1, dhatu2)
        
        # 3. Score global antagonisme
        antagonism_strength = (neuro_conflict_score + phenom_conflict_score) / 2
        
        # 4. Impact composabilit√©
        composability_impact = self._assess_composability_impact(dhatu1, dhatu2, antagonism_strength)
        
        # 5. M√©canismes r√©solution
        resolution_mechanisms = self._identify_resolution_mechanisms(dhatu1, dhatu2, antagonism_strength)
        
        # 6. Exemples r√©els
        real_examples = self._generate_real_world_examples(dhatu1, dhatu2)
        
        return AntagonismAnalysis(
            dhatu_pair=(dhatu1, dhatu2),
            antagonism_strength=antagonism_strength,
            neurobiological_conflict=neuro_conflict_desc,
            phenomenological_evidence=phenom_evidence,
            composability_impact=composability_impact,
            resolution_mechanisms=resolution_mechanisms,
            real_world_examples=real_examples
        )
    
    def _calculate_neurobiological_conflict(self, circuit1: Dict, circuit2: Dict) -> float:
        """Calcule conflit neurobiologique entre deux circuits"""
        
        score = 0.0
        
        # Comp√©tition neurotransmetteurs
        nt1 = set(circuit1['neurotransmitters'])
        nt2 = set(circuit2['neurotransmitters'])
        
        # Neurotransmetteurs oppos√©s connus
        opposing_pairs = [
            ('Dopamine', 'Cortisol'),
            ('Ocytocine', 'Testost√©rone'),
            ('GABA', 'Noradr√©naline')
        ]
        
        for nt_a, nt_b in opposing_pairs:
            if (nt_a in nt1 and nt_b in nt2) or (nt_b in nt1 and nt_a in nt2):
                score += 0.3
        
        # Comp√©tition circuits anatomiques
        circuits1 = set(circuit1['primary_circuits'])
        circuits2 = set(circuit2['primary_circuits'])
        
        # Circuits concurrents connus
        competing_regions = [
            ('Amygdale', 'Cortex Pr√©frontal'),
            ('VTA', 'Locus Coeruleus')
        ]
        
        for region_a, region_b in competing_regions:
            if (region_a in circuits1 and region_b in circuits2) or \
               (region_b in circuits1 and region_a in circuits2):
                score += 0.4
        
        # Inhibition document√©e
        if any(circuit2['activation_pattern'] in inhibitor 
               for inhibitor in circuit1.get('competes_with', [])):
            score += 0.5
            
        if any(circuit1['activation_pattern'] in inhibitor 
               for inhibitor in circuit2.get('competes_with', [])):
            score += 0.5
        
        return min(score, 1.0)
    
    def _describe_neurobiological_conflict(self, dhatu1: str, dhatu2: str, 
                                         circuit1: Dict, circuit2: Dict) -> str:
        """D√©crit conflit neurobiologique"""
        
        conflicts = []
        
        # Circuits oppos√©s
        if 'Amygdale' in circuit1['primary_circuits'] and \
           'Cortex Pr√©frontal' in circuit2['primary_circuits']:
            conflicts.append("Amygdale (√©motion) vs PFC (r√©gulation)")
            
        # Neurotransmetteurs
        if 'Dopamine' in circuit1['neurotransmitters'] and \
           'Cortisol' in circuit2['neurotransmitters']:
            conflicts.append("Dopamine (r√©compense) vs Cortisol (stress)")
            
        if not conflicts:
            conflicts.append(f"Activation {circuit1['activation_pattern']} vs {circuit2['activation_pattern']}")
            
        return "; ".join(conflicts)
    
    def _calculate_phenomenological_conflict(self, dhatu1: str, dhatu2: str) -> float:
        """Calcule conflit ph√©nom√©nologique"""
        
        # Cherche dans oppositions document√©es
        for opposition in self.phenomenological_oppositions:
            if set(opposition['pair']) == {dhatu1, dhatu2}:
                base_score = 0.8
                if opposition['intensity_dependency']:
                    return base_score * 0.8  # R√©ductible avec gestion intensit√©
                return base_score
        
        # Oppositions logiques implicites
        oppositions_logiques = {
            ('SEEK', 'FEAR'): 0.7,    # Approche vs √©vitement
            ('RAGE', 'CARE'): 0.8,    # Destruction vs construction  
            ('GRIEF', 'PLAY'): 0.6,   # Fermeture vs ouverture
            ('GRIEF', 'LUST'): 0.7,   # Retrait vs engagement
            ('RAGE', 'GRIEF'): 0.5    # Externalisation vs internalisation
        }
        
        pair_key = tuple(sorted([dhatu1, dhatu2]))
        return oppositions_logiques.get(pair_key, 0.2)  # Conflit faible par d√©faut
    
    def _get_phenomenological_evidence(self, dhatu1: str, dhatu2: str) -> str:
        """Obtient √©vidence ph√©nom√©nologique"""
        
        for opposition in self.phenomenological_oppositions:
            if set(opposition['pair']) == {dhatu1, dhatu2}:
                return opposition['description']
        
        # Descriptions par d√©faut
        default_descriptions = {
            ('RAGE', 'CARE'): "Impulsion destructrice vs protectrice",
            ('SEEK', 'FEAR'): "Curiosit√© vs prudence excessive",
            ('GRIEF', 'PLAY'): "Fermeture √©motionnelle vs ouverture ludique",
            ('GRIEF', 'LUST'): "Retrait vs engagement sensuel",
            ('RAGE', 'GRIEF'): "Action vs passivit√© √©motionnelle"
        }
        
        pair_key = tuple(sorted([dhatu1, dhatu2]))
        return default_descriptions.get(pair_key, "Opposition motivationnelle")
    
    def _assess_composability_impact(self, dhatu1: str, dhatu2: str, strength: float) -> str:
        """√âvalue impact sur composabilit√©"""
        
        if strength > 0.8:
            return "CRITIQUE - √âviter coactivation simultan√©e"
        elif strength > 0.6:
            return "MOD√âR√â - N√©cessite gestion intensit√©s ou alternance"
        elif strength > 0.4:
            return "L√âGER - Coexistence possible avec pr√©cautions"
        else:
            return "MINIMAL - Composition g√©n√©ralement viable"
    
    def _identify_resolution_mechanisms(self, dhatu1: str, dhatu2: str, strength: float) -> List[str]:
        """Identifie m√©canismes de r√©solution"""
        
        mechanisms = []
        
        if strength > 0.7:
            mechanisms.extend([
                "Alternance temporelle stricte",
                "S√©paration contextuelle",
                "Gestion intensit√© diff√©rentielle"
            ])
        elif strength > 0.5:
            mechanisms.extend([
                "Modulation intensit√©",
                "Transition graduelle",
                "Focus attentionnel s√©lectif"
            ])
        else:
            mechanisms.extend([
                "Coexistence naturelle possible",
                "√âquilibre dynamique"
            ])
            
        # M√©canismes sp√©cifiques
        specific_mechanisms = {
            ('RAGE', 'CARE'): ["Protection focalis√©e diff√©rentielle"],
            ('FEAR', 'SEEK'): ["Exploration graduelle s√©curis√©e"],
            ('GRIEF', 'PLAY'): ["Jeu th√©rapeutique progressif"]
        }
        
        pair_key = tuple(sorted([dhatu1, dhatu2]))
        if pair_key in specific_mechanisms:
            mechanisms.extend(specific_mechanisms[pair_key])
        
        return mechanisms
    
    def _generate_real_world_examples(self, dhatu1: str, dhatu2: str) -> List[str]:
        """G√©n√®re exemples concrets"""
        
        examples_map = {
            ('RAGE', 'CARE'): [
                "Parent en col√®re contre menace externe mais doux avec enfant",
                "D√©fense agressive du territoire familial",
                "Alternance col√®re-tendresse parentale"
            ],
            ('FEAR', 'SEEK'): [
                "Phobie sociale emp√™che exploration relationnelle", 
                "Anxi√©t√© performance bloque apprentissage",
                "Prudence excessive limite d√©couvertes"
            ],
            ('GRIEF', 'PLAY'): [
                "Deuil emp√™che jeu spontan√© enfant",
                "D√©pression = perte capacit√© ludique",
                "M√©lancolie cr√©ative vs anh√©donie"
            ],
            ('GRIEF', 'LUST'): [
                "Deuil conjugal inhibe d√©sir sexuel",
                "D√©pression diminue libido",
                "R√©cup√©ration lente apr√®s perte"
            ]
        }
        
        pair_key = tuple(sorted([dhatu1, dhatu2]))
        return examples_map.get(pair_key, ["Conflit motivationnel g√©n√©ral"])
    
    def _generate_resolution_strategies(self, antagonisms: List[Dict]) -> Dict[str, List[str]]:
        """G√©n√®re strat√©gies globales de r√©solution"""
        
        strategies = {
            'architectural': [
                "√âviter >2 antagonismes forts par composition",
                "Privil√©gier alternance temporelle pour conflits critiques",
                "Impl√©menter m√©canismes de transition gradu√©e"
            ],
            'implementation': [
                "Syst√®me de pond√©ration intensit√©",
                "D√©tection automatique conflits",
                "Suggestions compositions alternatives"
            ],
            'therapeutic': [
                "Reconnaissance patterns antagonistes personnels",
                "Techniques gestion √©motions conflictuelles",
                "D√©veloppement flexibilit√© √©motionnelle"
            ]
        }
        
        return strategies

def main():
    """Analyse avanc√©e antagonismes √©motionnels"""
    
    analyzer = AdvancedEmotionalAntagonismAnalyzer()
    results = analyzer.analyze_implicit_antagonisms()
    
    print(f"\nüéä SYNTH√àSE ANTAGONISMES AVANC√âE")
    print("=" * 35)
    
    classification = results['classification']
    print(f"üî¥ Antagonismes forts (>0.7): {classification['strong_antagonisms']}")
    print(f"üü° Antagonismes mod√©r√©s (0.5-0.7): {classification['moderate_antagonisms']}")
    print(f"üü¢ Antagonismes faibles (0.3-0.5): {classification['weak_antagonisms']}")
    
    print(f"\nüîß STRAT√âGIES R√âSOLUTION:")
    for category, strategies in results['resolution_strategies'].items():
        print(f"   {category.upper()}:")
        for strategy in strategies[:2]:
            print(f"     ‚Ä¢ {strategy}")
    
    # Sauvegarde
    timestamp = int(time.time())
    
    with open(f'analyse_antagonismes_avancee_{timestamp}.json', 'w', encoding='utf-8') as f:
        json.dump(results, f, indent=2, ensure_ascii=False)
    
    print(f"\nüíæ ANALYSE COMPL√àTE: analyse_antagonismes_avancee_{timestamp}.json")
    
    # Recommandation finale
    strong_count = classification['strong_antagonisms']
    if strong_count <= 2:
        print(f"\n‚úÖ CONCLUSION: Antagonismes g√©rables - Architecture Panksepp viable")
    elif strong_count <= 4:
        print(f"\n‚ö†Ô∏è CONCLUSION: Antagonismes mod√©r√©s - Pr√©cautions n√©cessaires")
    else:
        print(f"\n‚ùå CONCLUSION: Trop d'antagonismes - R√©vision architecture recommand√©e")

if __name__ == "__main__":
    main()