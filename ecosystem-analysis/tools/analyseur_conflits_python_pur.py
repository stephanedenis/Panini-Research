#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ANALYSEUR CONFLITS REPOSITORIES - PYTHON PUR
===========================================
Syst√®me Python autonome respectant les contraintes :
- PAS de shell (sh)
- PAS de python3 -c inline 
- PAS de pipes
- Autonomie compl√®te Python
"""

import json
import logging
from pathlib import Path
from datetime import datetime


class ConflictsAnalyzer:
    """Analyseur Python pur des conflits repositories"""
    
    def __init__(self):
        self.setup_logging()
        self.logger = logging.getLogger(__name__)
        self.audit_file = self.find_latest_audit_file()
        self.conflicts_data = None
    
    def setup_logging(self):
        """Configuration logging autonome"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('analyseur_conflits.log'),
                logging.StreamHandler()
            ]
        )
    
    def find_latest_audit_file(self) -> str:
        """Trouver le dernier fichier d'audit JSON"""
        current_dir = Path('.')
        audit_files = list(current_dir.glob('audit_repositories_github_*.json'))
        
        if not audit_files:
            return ""
        
        # Trier par date de modification (plus r√©cent en premier)
        latest_file = max(audit_files, key=lambda f: f.stat().st_mtime)
        return str(latest_file)
    
    def load_audit_data(self) -> bool:
        """Charger les donn√©es d'audit"""
        if not self.audit_file:
            self.logger.error("‚ùå Aucun fichier d'audit trouv√©")
            return False
        
        try:
            with open(self.audit_file, 'r', encoding='utf-8') as f:
                self.conflicts_data = json.load(f)
            
            self.logger.info(f"‚úÖ Donn√©es charg√©es: {self.audit_file}")
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur chargement: {e}")
            return False
    
    def analyze_conflicts_details(self):
        """Analyser les d√©tails des conflits"""
        self.logger.info("üîç ANALYSE D√âTAILL√âE CONFLITS")
        
        if not self.conflicts_data:
            self.logger.error("‚ùå Donn√©es non charg√©es")
            return
        
        conflicts = self.conflicts_data.get('conflicts', [])
        
        print("\n" + "="*60)
        print("üö® CONFLITS D√âTECT√âS - ANALYSE D√âTAILL√âE")
        print("="*60)
        
        # Regrouper par type
        conflicts_by_type = {}
        for conflict in conflicts:
            conflict_type = conflict['type']
            if conflict_type not in conflicts_by_type:
                conflicts_by_type[conflict_type] = []
            conflicts_by_type[conflict_type].append(conflict)
        
        for conflict_type, conflict_list in conflicts_by_type.items():
            print(f"\nüìã {conflict_type}: {len(conflict_list)} conflits")
            print("-" * 40)
            
            for conflict in conflict_list:
                self.print_conflict_details(conflict)
    
    def print_conflict_details(self, conflict):
        """Afficher d√©tails d'un conflit"""
        if conflict['type'] == 'RENAMING_NEEDED':
            print(f"   üîÑ {conflict['old_name']} ‚Üí {conflict['new_name']}")
            print(f"      üìÅ Path: {conflict['old_path']}")
            print(f"      üåê Remote: {conflict['remote_url']}")
            print(f"      ‚ö° Priorit√©: {conflict['priority']}")
            print(f"      ‚úÖ Nouveau existe: {conflict['new_exists']}")
            
        elif conflict['type'] == 'OBSOLETE_MODULE':
            print(f"   üóëÔ∏è  {conflict['name']}")
            print(f"      üìÅ Path: {conflict['path']}")
            print(f"      üí° Recommandation: {conflict['recommendation']}")
            print(f"      ‚ö° Priorit√©: {conflict['priority']}")
        
        print()
    
    def analyze_github_impact(self):
        """Analyser impact GitHub Projects"""
        self.logger.info("üìã ANALYSE IMPACT GITHUB PROJECTS")
        
        github_impacts = self.conflicts_data.get('github_projects_impact', [])
        
        if not github_impacts:
            print("\nüìã Aucun impact GitHub Projects d√©tect√©")
            return
        
        print("\n" + "="*60)
        print("üìã IMPACT GITHUB PROJECTS")
        print("="*60)
        
        for impact in github_impacts:
            print(f"\nüè† Repository: {impact['repository']}")
            print(f"   üîó URL: {impact['remote_url']}")
            print(f"   üìä Projets estim√©s: {impact['estimated_projects']}")
            print(f"   üîß Complexit√© migration: {impact['migration_complexity']}")
            print(f"   üí° Action recommand√©e: {impact['recommended_action']}")
    
    def analyze_migration_plan(self):
        """Analyser plan de migration"""
        self.logger.info("üöÄ ANALYSE PLAN MIGRATION")
        
        migrations = self.conflicts_data.get('migrations_needed', [])
        
        print("\n" + "="*60)
        print("üöÄ PLAN MIGRATION D√âTAILL√â")
        print("="*60)
        
        for i, migration in enumerate(migrations, 1):
            print(f"\n{i}. {migration['action']} - {migration['priority']}")
            print(f"   ‚è±Ô∏è  Dur√©e estim√©e: {migration['estimated_duration']}")
            
            if 'old_name' in migration:
                print(f"   üîÑ {migration['old_name']} ‚Üí {migration['new_name']}")
            
            print("   üìã √âtapes:")
            for step in migration['steps']:
                print(f"      ‚Ä¢ {step}")
            
            print("   ‚ö†Ô∏è  Risques:")
            for risk in migration['risks']:
                print(f"      ‚Ä¢ {risk}")
    
    def generate_action_priorities(self):
        """G√©n√©rer priorit√©s d'actions"""
        self.logger.info("üéØ G√âN√âRATION PRIORIT√âS ACTIONS")
        
        print("\n" + "="*60)
        print("üéØ ACTIONS PRIORITAIRES RECOMMAND√âES")
        print("="*60)
        
        # Analyser conflits par priorit√©
        high_priority = []
        medium_priority = []
        low_priority = []
        
        for conflict in self.conflicts_data.get('conflicts', []):
            priority = conflict.get('priority', 'LOW')
            if priority == 'HIGH':
                high_priority.append(conflict)
            elif priority == 'MEDIUM':
                medium_priority.append(conflict)
            else:
                low_priority.append(conflict)
        
        print(f"\nüî• PRIORIT√â HAUTE ({len(high_priority)} actions)")
        for conflict in high_priority:
            if conflict['type'] == 'RENAMING_NEEDED':
                print(f"   ‚Ä¢ Renommer GitHub: {conflict['old_name']} ‚Üí {conflict['new_name']}")
        
        print(f"\n‚ö° PRIORIT√â MOYENNE ({len(medium_priority)} actions)")
        for conflict in medium_priority:
            if conflict['type'] == 'RENAMING_NEEDED':
                print(f"   ‚Ä¢ Renommer local: {conflict['old_name']} ‚Üí {conflict['new_name']}")
        
        print(f"\nüìã PRIORIT√â BASSE ({len(low_priority)} actions)")
        for conflict in low_priority:
            if conflict['type'] == 'OBSOLETE_MODULE':
                print(f"   ‚Ä¢ √âvaluer module: {conflict['name']}")
    
    def generate_immediate_todo(self):
        """G√©n√©rer TODO imm√©diat"""
        self.logger.info("üìù G√âN√âRATION TODO IMM√âDIAT")
        
        immediate_actions = []
        
        # Actions bas√©es sur les conflits haute priorit√©
        for conflict in self.conflicts_data.get('conflicts', []):
            if conflict.get('priority') == 'HIGH' and conflict['type'] == 'RENAMING_NEEDED':
                immediate_actions.append({
                    "action": f"Renommer GitHub repository",
                    "details": f"{conflict['old_name']} ‚Üí {conflict['new_name']}",
                    "reason": "Coh√©rence architecture post-refactoring",
                    "impact": "GitHub Projects/Issues potentiellement affect√©s"
                })
        
        # Sauvegarder TODO
        todo_content = {
            "generated": datetime.now().isoformat(),
            "source": "audit_repositories_github_autonome.py",
            "immediate_actions": immediate_actions,
            "context": "Post-refactoring architecture Panini",
            "priority": "HIGH - Actions GitHub requises"
        }
        
        todo_file = f"TODO_REPOSITORIES_GITHUB_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        try:
            with open(todo_file, 'w', encoding='utf-8') as f:
                json.dump(todo_content, f, indent=2, ensure_ascii=False)
            
            print(f"\nüìù TODO g√©n√©r√©: {todo_file}")
            
            # Afficher r√©sum√© TODO
            print("\n" + "="*60)
            print("üìù TODO IMM√âDIAT - REPOSITORIES GITHUB")
            print("="*60)
            
            for i, action in enumerate(immediate_actions, 1):
                print(f"\n{i}. {action['action']}")
                print(f"   üîÑ {action['details']}")
                print(f"   üí° Raison: {action['reason']}")
                print(f"   ‚ö†Ô∏è  Impact: {action['impact']}")
            
            return todo_file
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur g√©n√©ration TODO: {e}")
            return ""
    
    def run_complete_analysis(self) -> bool:
        """Ex√©cution compl√®te analyse Python pure"""
        self.logger.info("üöÄ D√âMARRAGE ANALYSE CONFLITS PYTHON PUR")
        
        try:
            # Charger donn√©es audit
            if not self.load_audit_data():
                return False
            
            # Analyses d√©taill√©es
            self.analyze_conflicts_details()
            self.analyze_github_impact()  
            self.analyze_migration_plan()
            self.generate_action_priorities()
            todo_file = self.generate_immediate_todo()
            
            print("\n" + "="*60)
            print("‚úÖ ANALYSE COMPL√àTE TERMIN√âE")
            print("="*60)
            print(f"üìä Donn√©es source: {self.audit_file}")
            print(f"üìù TODO g√©n√©r√©: {todo_file}")
            print("üéØ Actions prioritaires identifi√©es")
            print("="*60)
            
            return True
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur analyse: {e}")
            return False


def main():
    """Point d'entr√©e principal - Python pur"""
    print("üîç ANALYSEUR CONFLITS REPOSITORIES - PYTHON PUR")
    print("===============================================")
    print("Respect contraintes autonomie : pas sh, pipes, python3 -c")
    print()
    
    analyzer = ConflictsAnalyzer()
    success = analyzer.run_complete_analysis()
    
    if success:
        print("\n‚úÖ ANALYSE PYTHON PUR R√âUSSIE")
        print("üìã Actions prioritaires identifi√©es")
    else:
        print("\n‚ùå √âCHEC ANALYSE")
        print("üìã V√©rifiez logs pour diagnostic")
    
    return success


if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)