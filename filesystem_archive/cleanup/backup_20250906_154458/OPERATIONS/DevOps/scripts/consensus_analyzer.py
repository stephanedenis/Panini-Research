#!/usr/bin/env python3
"""
Analyseur de consensus avec d√©tection patterns
"""

import json
from collections import defaultdict
from typing import Dict, List
import re
import sys
import os

# Ajouter le r√©pertoire parent pour imports
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

class ConsensusAnalyzer:
    def __init__(self, store_file: str):
        try:
            with open(store_file, 'r', encoding='utf-8') as f:
                self.store = json.load(f)
            self.atoms = self.store['semantic_atoms']
            print(f"üìä Charg√© {len(self.atoms)} atomes s√©mantiques")
        except FileNotFoundError:
            print(f"‚ùå Fichier {store_file} non trouv√©")
            self.store = {"semantic_atoms": []}
            self.atoms = []
        except Exception as e:
            print(f"‚ùå Erreur chargement: {e}")
            self.atoms = []
        
    def analyze_definition_patterns(self) -> Dict:
        """D√©tecte patterns dans d√©finitions"""
        patterns = defaultdict(list)
        
        for atom in self.atoms:
            definition = atom['definition'].lower()
            concept = atom['concept']
            
            # Patterns linguistiques IA/informatique
            if any(word in definition for word in ['apprentissage', 'apprendre', 'learning']):
                patterns['learning_based'].append(concept)
            if any(word in definition for word in ['r√©seau', 'neurone', 'neuronal', 'network']):
                patterns['network_based'].append(concept)
            if any(word in definition for word in ['algorithme', 'algorithm', 'programme']):
                patterns['algorithmic'].append(concept)
            if any(word in definition for word in ['donn√©es', 'data', 'information']):
                patterns['data_driven'].append(concept)
            if any(word in definition for word in ['intelligence', 'intelligent', 'artificiel']):
                patterns['ai_related'].append(concept)
            if any(word in definition for word in ['syst√®me', 'system', 'informatique']):
                patterns['system_based'].append(concept)
                
        return dict(patterns)
        
    def detect_semantic_clusters(self) -> List[Dict]:
        """Clustering basique par mots-cl√©s communs"""
        clusters = []
        
        if not self.atoms:
            return clusters
        
        # Extraction mots-cl√©s par concept
        concept_keywords = {}
        for atom in self.atoms:
            # Extraction mots significatifs (4+ caract√®res)
            text = atom['definition'].lower() + " " + atom['context'][:200].lower()
            words = set(re.findall(r'\b\w{4,}\b', text))
            # Filtrer mots vides
            stop_words = {'cette', 'sont', 'pour', 'dans', 'avec', '√™tre', 'avoir', 'leur', 'leurs', 'elle', 'elles', 'plus', 'tr√®s', 'tout', 'tous', 'peut', 'faire', 'autre', 'm√™me', 'aussi', 'bien', 'encore', 'alors', 'ainsi', 'depuis', 'pendant', 'avant', 'apr√®s'}
            words = words - stop_words
            concept_keywords[atom['concept']] = words
            
        # Similarit√© par intersection
        concepts = list(concept_keywords.keys())
        for i, concept1 in enumerate(concepts):
            cluster = {'core_concept': concept1, 'related': [], 'similarity_scores': [], 'shared_keywords': []}
            
            for j, concept2 in enumerate(concepts):
                if i != j:
                    words1 = concept_keywords[concept1]
                    words2 = concept_keywords[concept2]
                    
                    intersection = words1 & words2
                    union = words1 | words2
                    similarity = len(intersection) / len(union) if union else 0
                    
                    if similarity > 0.1:  # Seuil arbitraire
                        cluster['related'].append(concept2)
                        cluster['similarity_scores'].append(round(similarity, 3))
                        cluster['shared_keywords'].append(list(intersection)[:5])  # Top 5 mots communs
                        
            if cluster['related']:
                clusters.append(cluster)
                
        return clusters
        
    def extract_key_concepts(self) -> Dict:
        """Extraction concepts-cl√©s par fr√©quence"""
        word_freq = defaultdict(int)
        concept_cooccurrence = defaultdict(list)
        
        for atom in self.atoms:
            text = atom['definition'].lower()
            words = re.findall(r'\b\w{5,}\b', text)  # Mots 5+ caract√®res
            
            for word in words:
                if word not in ['cette', 'sont', 'pour', 'dans', 'avec', 'intelligence', 'artificielle']:
                    word_freq[word] += 1
                    concept_cooccurrence[word].append(atom['concept'])
        
        # Top concepts par fr√©quence
        top_concepts = sorted(word_freq.items(), key=lambda x: x[1], reverse=True)[:10]
        
        return {
            'frequent_terms': top_concepts,
            'cross_concept_terms': {word: list(set(concepts)) for word, concepts in concept_cooccurrence.items() if len(set(concepts)) > 1}
        }
        
    def generate_consensus_report(self) -> Dict:
        """Rapport consensus avec m√©triques"""
        if not self.atoms:
            return {
                "error": "Aucun atome s√©mantique √† analyser",
                "analysis_metadata": {
                    "total_concepts": 0,
                    "analysis_date": "2024-11-30",
                    "analyzer_version": "0.1.0"
                }
            }
            
        patterns = self.analyze_definition_patterns()
        clusters = self.detect_semantic_clusters()
        key_concepts = self.extract_key_concepts()
        
        # M√©triques de diversit√©
        total_words = sum(len(atom['definition'].split()) for atom in self.atoms)
        avg_definition_length = total_words / len(self.atoms) if self.atoms else 0
        
        # Sources d'extraction
        sources = set(atom['provenance']['source_url'] for atom in self.atoms)
        agents = set(atom['provenance']['source_agent'] for atom in self.atoms)
        
        report = {
            "analysis_metadata": {
                "total_concepts": len(self.atoms),
                "unique_sources": len(sources),
                "unique_agents": len(agents),
                "avg_definition_length": round(avg_definition_length, 1),
                "analysis_date": "2024-11-30",
                "analyzer_version": "0.1.0"
            },
            "semantic_patterns": patterns,
            "concept_clusters": clusters,
            "key_concepts": key_concepts,
            "consensus_metrics": {
                "pattern_coverage": {pattern: len(concepts)/len(self.atoms) 
                                  for pattern, concepts in patterns.items()},
                "cluster_density": len(clusters) / len(self.atoms) if self.atoms else 0,
                "avg_cluster_size": sum(len(c['related']) for c in clusters) / len(clusters) if clusters else 0,
                "conceptual_diversity": len(set(atom['concept'] for atom in self.atoms)) / len(self.atoms) if self.atoms else 0
            },
            "provenance_analysis": {
                "source_distribution": list(sources),
                "agent_distribution": list(agents),
                "temporal_range": {
                    "earliest": min(atom['provenance']['timestamp'] for atom in self.atoms) if self.atoms else None,
                    "latest": max(atom['provenance']['timestamp'] for atom in self.atoms) if self.atoms else None
                }
            }
        }
        
        return report
        
    def save_analysis(self, filename: str):
        """Sauvegarde analyse"""
        report = self.generate_consensus_report()
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
            
        print(f"‚úÖ Analyse consensus sauv√©e: {filename}")
        return report
        
    def print_summary(self, report: Dict):
        """Affichage r√©sum√© console"""
        print("\nüß† ANALYSE PATTERNS S√âMANTIQUES")
        print("=" * 40)
        
        metadata = report.get('analysis_metadata', {})
        print(f"üìä Total concepts: {metadata.get('total_concepts', 0)}")
        print(f"üåê Sources uniques: {metadata.get('unique_sources', 0)}")
        print(f"ü§ñ Agents uniques: {metadata.get('unique_agents', 0)}")
        print(f"üìù Longueur moy. d√©finition: {metadata.get('avg_definition_length', 0)} mots")
        
        patterns = report.get('semantic_patterns', {})
        if patterns:
            print(f"\nüîç PATTERNS D√âTECT√âS:")
            for pattern, concepts in patterns.items():
                print(f"  ‚Ä¢ {pattern}: {', '.join(concepts)}")
        
        clusters = report.get('concept_clusters', [])
        if clusters:
            print(f"\nüîó CLUSTERS S√âMANTIQUES:")
            for cluster in clusters[:3]:  # Top 3
                core = cluster['core_concept']
                related = cluster['related'][:2]  # Top 2
                similarity = cluster['similarity_scores'][0] if cluster['similarity_scores'] else 0
                print(f"  ‚Ä¢ {core} ‚Üí {related} (sim: {similarity:.2f})")
        
        key_concepts = report.get('key_concepts', {})
        frequent = key_concepts.get('frequent_terms', [])
        if frequent:
            print(f"\nüèÜ CONCEPTS FR√âQUENTS:")
            for word, freq in frequent[:5]:
                print(f"  ‚Ä¢ {word}: {freq} occurrences")

def main():
    print("üß† ANALYSEUR CONSENSUS S√âMANTIQUE")
    print("================================")
    
    store_file = "demo_semantic_store.json"
    if not os.path.exists(store_file):
        print(f"‚ùå Fichier {store_file} non trouv√©")
        print("üí° Lancez d'abord: python collect_with_attribution.py")
        return
    
    analyzer = ConsensusAnalyzer(store_file)
    
    if not analyzer.atoms:
        print("‚ùå Aucun atome s√©mantique √† analyser")
        return
    
    print(f"üîç Analyse de {len(analyzer.atoms)} atomes...")
    
    analysis_file = "consensus_analysis.json"
    report = analyzer.save_analysis(analysis_file)
    
    # Affichage r√©sum√©
    analyzer.print_summary(report)
    
    print(f"\nüéØ ANALYSE TERMIN√âE")
    print(f"üìÑ Rapport d√©taill√©: {analysis_file}")
    print(f"üîß Prochaine √©tape: python traceability_dashboard.py")

if __name__ == "__main__":
    main()
