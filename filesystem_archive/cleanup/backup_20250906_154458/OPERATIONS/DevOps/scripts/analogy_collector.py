#!/usr/bin/env python3
"""
Collecteur Analogies et M√©taphores - M√©canismes cognitifs et limites
üîó Exploration analogies, m√©taphores, correspondances avec marquage limites explicites
"""

import json
import datetime
from typing import List, Dict, Any, Optional
import re
import os

class AnalogyCollector:
    def __init__(self):
        self.store = {
            "metadata": {
                "version": "1.0",
                "description": "Collection analogies avec marquage limites explicites",
                "creation_date": datetime.datetime.now().isoformat(),
                "source_type": "analogy_mapping",
                "focus_areas": ["cognitive_analogies", "scientific_metaphors", "limit_boundaries", "mapping_failures"]
            },
            "semantic_atoms": []
        }
    
    def collect_cognitive_analogies(self) -> List[Dict]:
        """Analogies cognitives fondamentales avec limites explicites"""
        concepts = [
            {
                "concept": "Analogie Hydraulique √âlectricit√©",
                "definition": "Correspondance eau/courant, pression/tension, r√©sistance/√©troitesse pour comprendre circuits √©lectriques",
                "category": "scientific_analogy",
                "source_domain": "hydraulique",
                "target_domain": "√©lectricit√©",
                "valid_mappings": {
                    "d√©bit_eau": "intensit√©_courant",
                    "pression": "tension",
                    "tuyau_√©troit": "r√©sistance",
                    "r√©servoir": "condensateur"
                },
                "boundary_limits": {
                    "breakdown_points": ["fr√©quences_hautes", "effets_quantiques", "champs_electromagn√©tiques"],
                    "invalid_mappings": ["temp√©rature_eau ‚â† temp√©rature_√©lectrique", "viscosit√© ‚â† imp√©dance_complexe"],
                    "domain_restrictions": "circuits_DC_basse_fr√©quence_uniquement"
                },
                "cognitive_utility": "mn√©monique_intuition_initiale",
                "pedagogical_value": 0.85,
                "precision_limit": 0.6,
                "relevance_score": 0.92
            },
            {
                "concept": "M√©taphore Syst√®me Solaire Atome",
                "definition": "Mod√®le plan√©taire atome avec √©lectrons orbitant noyau, analogie gravitationnelle pour structure atomique",
                "category": "historical_analogy",
                "source_domain": "syst√®me_solaire",
                "target_domain": "structure_atomique",
                "valid_mappings": {
                    "soleil": "noyau",
                    "plan√®tes": "√©lectrons",
                    "orbites": "niveaux_√©nergie",
                    "attraction_gravitationnelle": "attraction_coulombienne"
                },
                "boundary_limits": {
                    "breakdown_points": ["m√©canique_quantique", "principe_incertitude", "dualit√©_onde_particule"],
                    "invalid_mappings": ["orbites_d√©finies ‚â† nuages_probabilit√©", "rayonnement_√©nergie_impossible"],
                    "domain_restrictions": "pr√©_quantique_intuition_grossi√®re",
                    "historical_obsolescence": "remplac√©_mod√®le_quantique_1925"
                },
                "cognitive_utility": "introduction_structure_atomique",
                "pedagogical_value": 0.7,
                "precision_limit": 0.3,
                "relevance_score": 0.88
            },
            {
                "concept": "Analogie Cerveau Ordinateur",
                "definition": "Correspondance traitement information cerveau/ordinateur, m√©moire/stockage, processus/algorithmes",
                "category": "computational_analogy",
                "source_domain": "informatique",
                "target_domain": "neurosciences",
                "valid_mappings": {
                    "processeur": "neurones",
                    "m√©moire_ram": "m√©moire_travail",
                    "stockage": "m√©moire_long_terme",
                    "algorithmes": "processus_cognitifs"
                },
                "boundary_limits": {
                    "breakdown_points": ["plasticit√©_neuronale", "√©motions", "conscience", "apprentissage_continu"],
                    "invalid_mappings": ["binaire ‚â† graduel", "s√©quentiel ‚â† parall√®le_massif", "logique ‚â† √©motionnel"],
                    "domain_restrictions": "aspects_computationnels_restreints",
                    "oversimplification_risk": "r√©duction_conscience_calcul"
                },
                "cognitive_utility": "mod√©lisation_aspects_informationnels",
                "pedagogical_value": 0.75,
                "precision_limit": 0.5,
                "relevance_score": 0.83
            },
            {
                "concept": "M√©taphore ADN Code Informatique",
                "definition": "Correspondance s√©quences ADN/code programme, g√®nes/fonctions, expression/ex√©cution",
                "category": "biological_analogy",
                "source_domain": "programmation",
                "target_domain": "g√©n√©tique",
                "valid_mappings": {
                    "code_source": "s√©quence_ADN",
                    "fonctions": "g√®nes",
                    "variables": "prot√©ines",
                    "compilation": "transcription_traduction",
                    "ex√©cution": "expression_g√©nique"
                },
                "boundary_limits": {
                    "breakdown_points": ["√©pig√©n√©tique", "r√©gulation_complexe", "environnement_cellulaire", "√©volution"],
                    "invalid_mappings": ["d√©terminisme_strict ‚â† r√©gulation_dynamique", "bugs ‚â† mutations_b√©n√©fiques"],
                    "domain_restrictions": "aspects_informationnels_basiques",
                    "complexity_underestimation": "interactions_multi_niveaux_ignor√©es"
                },
                "cognitive_utility": "compr√©hension_h√©r√©dit√©_information",
                "pedagogical_value": 0.8,
                "precision_limit": 0.55,
                "relevance_score": 0.87
            },
            {
                "concept": "Analogie R√©seau Social Neurones",
                "definition": "Correspondance connexions sociales/synapses, influence/poids synaptiques, propagation/activation",
                "category": "network_analogy",
                "source_domain": "r√©seaux_sociaux",
                "target_domain": "r√©seaux_neuronaux",
                "valid_mappings": {
                    "individus": "neurones",
                    "connexions_amis": "synapses",
                    "influence": "poids_synaptiques",
                    "rumeur_propagation": "propagation_signal",
                    "leaders_opinion": "neurones_hub"
                },
                "boundary_limits": {
                    "breakdown_points": ["vitesse_propagation", "nature_signal", "plasticit√©_temporelle"],
                    "invalid_mappings": ["contenu_s√©mantique ‚â† √©lectrochimique", "volont√© ‚â† automatisme"],
                    "domain_restrictions": "structure_topologique_uniquement",
                    "abstraction_level": "dynamiques_√©mergentes_similaires"
                },
                "cognitive_utility": "compr√©hension_r√©seaux_complexes",
                "pedagogical_value": 0.78,
                "precision_limit": 0.6,
                "relevance_score": 0.81
            }
        ]
        
        return self._convert_to_atoms(concepts, "cognitive_analogies")
    
    def collect_mathematical_analogies(self) -> List[Dict]:
        """Analogies math√©matiques avec domaines validit√©"""
        concepts = [
            {
                "concept": "Analogie D√©riv√©e Pente",
                "definition": "Correspondance d√©riv√©e fonction/pente tangente, changement instantan√©/inclinaison g√©om√©trique",
                "category": "mathematical_analogy",
                "source_domain": "g√©om√©trie_euclidienne",
                "target_domain": "calcul_diff√©rentiel",
                "valid_mappings": {
                    "pente_droite": "d√©riv√©e_constante",
                    "tangente_courbe": "d√©riv√©e_point",
                    "mont√©e_descente": "signe_d√©riv√©e",
                    "raideur": "valeur_absolue_d√©riv√©e"
                },
                "boundary_limits": {
                    "breakdown_points": ["fonctions_non_d√©rivables", "discontinuit√©s", "dimensions_sup√©rieures"],
                    "invalid_mappings": ["pente_infinie ‚â† d√©riv√©e_complexe", "ligne_droite ‚â† variation_locale"],
                    "domain_restrictions": "fonctions_lisses_1D",
                    "conceptual_precision": "approximation_locale_uniquement"
                },
                "cognitive_utility": "visualisation_changement_instantan√©",
                "pedagogical_value": 0.9,
                "precision_limit": 0.8,
                "relevance_score": 0.93
            },
            {
                "concept": "M√©taphore Int√©grale Aire",
                "definition": "Correspondance int√©grale/aire sous courbe, accumulation/surface g√©om√©trique",
                "category": "mathematical_analogy", 
                "source_domain": "g√©om√©trie_aires",
                "target_domain": "calcul_int√©gral",
                "valid_mappings": {
                    "aire_rectangle": "somme_riemann",
                    "surface_courbe": "int√©grale_d√©finie",
                    "accumulation": "primitive",
                    "d√©coupage_fin": "limite_partitions"
                },
                "boundary_limits": {
                    "breakdown_points": ["int√©grales_g√©n√©ralis√©es", "mesures_complexes", "espaces_abstraits"],
                    "invalid_mappings": ["aire_n√©gative ‚â† surface_physique", "infini ‚â† g√©om√©trie_euclidienne"],
                    "domain_restrictions": "fonctions_continues_positives",
                    "abstraction_leap": "de_g√©om√©trique_vers_analytique"
                },
                "cognitive_utility": "intuition_accumulation_continue",
                "pedagogical_value": 0.88,
                "precision_limit": 0.75,
                "relevance_score": 0.91
            },
            {
                "concept": "Analogie Vecteur Fl√®che",
                "definition": "Correspondance vecteur math√©matique/fl√®che physique, direction/orientation, magnitude/longueur",
                "category": "mathematical_analogy",
                "source_domain": "objets_physiques",
                "target_domain": "alg√®bre_lin√©aire",
                "valid_mappings": {
                    "fl√®che": "vecteur_g√©om√©trique",
                    "longueur": "norme",
                    "direction": "direction_math√©matique",
                    "bout_fl√®che": "point_arriv√©e",
                    "addition_forces": "addition_vectorielle"
                },
                "boundary_limits": {
                    "breakdown_points": ["espaces_abstraits", "dimensions_sup√©rieures", "espaces_fonctionnels"],
                    "invalid_mappings": ["mati√®re_physique ‚â† entit√©_abstraite", "3D_visuel ‚â† nD_math√©matique"],
                    "domain_restrictions": "vecteurs_g√©om√©triques_2D_3D",
                    "conceptual_limitation": "visualisation_limit√©e_dimensions"
                },
                "cognitive_utility": "intuition_g√©om√©trique_op√©rations",
                "pedagogical_value": 0.85,
                "precision_limit": 0.7,
                "relevance_score": 0.89
            }
        ]
        
        return self._convert_to_atoms(concepts, "mathematical_analogies")
    
    def collect_analogy_failures(self) -> List[Dict]:
        """√âchecs analogies c√©l√®bres - le√ßons limites"""
        concepts = [
            {
                "concept": "√âchec Analogie √âther Luminif√®re",
                "definition": "Analogie son/air ‚Üí lumi√®re/√©ther √©choue, r√©v√®le nature ondulatoire sans support mat√©riel",
                "category": "historical_failure",
                "failed_mapping": {
                    "source_domain": "propagation_son_air",
                    "target_domain": "propagation_lumi√®re",
                    "assumed_correspondence": "air/son ‚Üí √©ther/lumi√®re"
                },
                "failure_points": {
                    "empirical_refutation": "exp√©rience_michelson_morley",
                    "theoretical_breakthrough": "relativit√©_restreinte",
                    "conceptual_revolution": "ondes_sans_support_mat√©riel"
                },
                "lessons_learned": {
                    "analogie_limitation": "similarit√©_superficielle_trompeuse",
                    "empirical_necessity": "test_exp√©rimental_crucial",
                    "paradigm_shift": "abandon_analogie_pour_nouveau_concept"
                },
                "cognitive_impact": "r√©vision_concepts_fondamentaux",
                "historical_importance": 0.95,
                "relevance_score": 0.88
            },
            {
                "concept": "Pi√®ge Analogie Vitesse Lumi√®re Projectile",
                "definition": "Analogie vitesse projectile/vitesse lumi√®re √©choue, r√©v√®le relativit√© et limite universelle",
                "category": "conceptual_trap",
                "failed_mapping": {
                    "source_domain": "m√©canique_classique",
                    "target_domain": "√©lectromagn√©tisme",
                    "assumed_correspondence": "addition_vitesses_galileenne"
                },
                "failure_points": {
                    "invariance_c": "vitesse_lumi√®re_constante",
                    "relativistic_effects": "dilatation_temps_contraction_espace",
                    "energy_mass": "√©quivalence_masse_√©nergie"
                },
                "lessons_learned": {
                    "universal_constants": "certaines_quantit√©s_absolues",
                    "scale_dependence": "physique_change_selon_√©chelle",
                    "counter_intuitive": "r√©alit√©_d√©passe_intuition_quotidienne"
                },
                "cognitive_impact": "r√©vision_concepts_espace_temps",
                "historical_importance": 0.92,
                "relevance_score": 0.86
            }
        ]
        
        return self._convert_to_atoms(concepts, "analogy_failures")
    
    def collect_metaanalogy_theory(self) -> List[Dict]:
        """Th√©orie m√©ta-analogique - structure mappings cognitifs"""
        concepts = [
            {
                "concept": "Structure Mapping Theory",
                "definition": "Th√©orie Gentner: analogie = alignement structures relationnelles pr√©servant consistance syst√©matique",
                "category": "cognitive_theory",
                "mapping_principles": {
                    "systematicity": "pr√©f√©rence_syst√®mes_relations_coh√©rents",
                    "one_to_one": "correspondance_unique_√©l√©ments",
                    "parallel_connectivity": "pr√©servation_structure_relationnelle"
                },
                "analogy_components": {
                    "surface_similarity": "similarit√©s_superficielles_attributs",
                    "structural_alignment": "correspondance_relations_profondes",
                    "pragmatic_centrality": "importance_but_analogie"
                },
                "quality_factors": {
                    "systematicity_principle": "coh√©rence_syst√®me_relations",
                    "semantic_similarity": "proximit√©_domaines_source_cible",
                    "pragmatic_importance": "pertinence_objectif_cognitif"
                },
                "cognitive_utility": "mod√®le_traitement_analogique",
                "theoretical_support": 0.9,
                "relevance_score": 0.94
            },
            {
                "concept": "Analogical Reasoning Limits",
                "definition": "Limites raisonnement analogique: bootstrap problem, projection s√©lective, induction superficielle",
                "category": "cognitive_limits",
                "limitation_types": {
                    "bootstrap_problem": "analogie_n√©cessite_connaissance_pr√©alable",
                    "selective_projection": "choix_aspects_mapp√©s_subjectif",
                    "surface_similarity_bias": "pi√®ge_similarit√©s_superficielles",
                    "overgeneralization": "extension_excessive_domaine_validit√©"
                },
                "mitigation_strategies": {
                    "explicit_boundary_marking": "d√©limitation_explicite_domaine",
                    "multiple_analogies": "triangulation_analogies_multiples",
                    "empirical_validation": "test_pr√©dictions_analogiques",
                    "structural_focus": "privil√©gier_relations_sur_attributs"
                },
                "panini_implications": {
                    "boundary_atoms": "atomes_fronti√®res_explicites",
                    "analogy_markers": "marquage_nature_analogique",
                    "validity_scope": "domaine_validit√©_encod√©",
                    "confidence_gradation": "gradation_confiance_mapping"
                },
                "cognitive_utility": "pr√©vention_erreurs_analogiques",
                "theoretical_support": 0.85,
                "relevance_score": 0.91
            }
        ]
        
        return self._convert_to_atoms(concepts, "metaanalogy_theory")
    
    def _convert_to_atoms(self, concepts: List[Dict], collection_type: str) -> List[Dict]:
        """Conversion concepts analogiques en atomes avec marquage sp√©cialis√©"""
        atoms = []
        
        for i, concept_data in enumerate(concepts):
            # Extraction marquage analogique sp√©cialis√©
            analogy_markers = self._extract_analogy_markers(concept_data)
            
            atom = {
                "concept": concept_data["concept"],
                "definition": concept_data["definition"],
                "category": concept_data["category"],
                "analogy_structure": analogy_markers,
                "metadata": {
                    key: value for key, value in concept_data.items()
                    if key not in ["concept", "definition", "category"]
                },
                "provenance": {
                    "source_agent": "analogy_collector",
                    "timestamp": datetime.datetime.now().isoformat(),
                    "extraction_confidence": concept_data.get("relevance_score", 0.85),
                    "collection_method": f"structured_{collection_type}",
                    "atom_id": f"analogy_{datetime.datetime.now().strftime('%Y%m%d')}_{collection_type}_{i:03d}"
                }
            }
            atoms.append(atom)
        
        return atoms
    
    def _extract_analogy_markers(self, concept_data: Dict) -> Dict:
        """Extraction marqueurs analogiques selon structure PaniniFS"""
        markers = {
            "analogy_type": "explicit_marked_analogy",
            "mapping_quality": "provisional_with_boundaries"
        }
        
        # Marquage domaines source/cible si pr√©sents
        if "source_domain" in concept_data and "target_domain" in concept_data:
            markers["domain_mapping"] = {
                "source": concept_data["source_domain"],
                "target": concept_data["target_domain"],
                "mapping_direction": "source_to_target"
            }
        
        # Marquage limites si pr√©sentes
        if "boundary_limits" in concept_data:
            markers["boundary_conditions"] = concept_data["boundary_limits"]
            markers["validity_scope"] = "limited_domain_with_explicit_boundaries"
        
        # Marquage correspondances valides/invalides
        if "valid_mappings" in concept_data:
            markers["valid_correspondences"] = concept_data["valid_mappings"]
        
        if "invalid_mappings" in concept_data.get("boundary_limits", {}):
            markers["invalid_correspondences"] = concept_data["boundary_limits"]["invalid_mappings"]
        
        # Utilit√© cognitive et limites pr√©cision
        if "cognitive_utility" in concept_data:
            markers["cognitive_function"] = concept_data["cognitive_utility"]
        
        if "precision_limit" in concept_data:
            markers["precision_boundary"] = concept_data["precision_limit"]
            markers["warning"] = "analogie_mn√©monique_limites_explicites"
        
        return markers
    
    def collect_all_analogies(self) -> List[Dict]:
        """Collection compl√®te analogies avec marquage limites"""
        all_atoms = []
        
        print("üß† Collecte analogies cognitives...")
        all_atoms.extend(self.collect_cognitive_analogies())
        
        print("üî¢ Collecte analogies math√©matiques...")
        all_atoms.extend(self.collect_mathematical_analogies())
        
        print("‚ùå Collecte √©checs analogiques...")
        all_atoms.extend(self.collect_analogy_failures())
        
        print("üéØ Collecte th√©orie m√©ta-analogique...")
        all_atoms.extend(self.collect_metaanalogy_theory())
        
        return all_atoms
    
    def save_collection(self, filename: str = "analogy_semantic_store.json"):
        """Sauvegarde collection analogies avec structure marquage"""
        atoms = self.collect_all_analogies()
        self.store["semantic_atoms"] = atoms
        self.store["metadata"]["total_atoms"] = len(atoms)
        
        # Analyse marqueurs analogiques
        analogy_stats = {
            "explicit_boundaries": 0,
            "domain_mappings": 0,
            "precision_limits": 0,
            "cognitive_utilities": 0
        }
        
        for atom in atoms:
            markers = atom.get("analogy_structure", {})
            if "boundary_conditions" in markers:
                analogy_stats["explicit_boundaries"] += 1
            if "domain_mapping" in markers:
                analogy_stats["domain_mappings"] += 1
            if "precision_boundary" in markers:
                analogy_stats["precision_limits"] += 1
            if "cognitive_function" in markers:
                analogy_stats["cognitive_utilities"] += 1
        
        self.store["metadata"]["analogy_markers"] = analogy_stats
        self.store["metadata"]["boundary_marking_principle"] = "toute_analogie_avec_limites_explicites"
        
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(self.store, f, indent=2, ensure_ascii=False)
        
        print(f"‚úÖ Collection analogies sauv√©e: {filename}")
        print(f"üìä {len(atoms)} analogies collect√©es avec marquage limites")
        print(f"üîó Marqueurs analogiques:")
        print(f"   ‚Ä¢ {analogy_stats['explicit_boundaries']} fronti√®res explicites")
        print(f"   ‚Ä¢ {analogy_stats['domain_mappings']} mappings domaines")
        print(f"   ‚Ä¢ {analogy_stats['precision_limits']} limites pr√©cision")
        print(f"   ‚Ä¢ {analogy_stats['cognitive_utilities']} utilit√©s cognitives")
        
        return len(atoms)

def main():
    print("üîó COLLECTEUR ANALOGIES AVEC MARQUAGE LIMITES")
    print("==============================================")
    print("üéØ Analogies cognitives, √©checs historiques, m√©ta-th√©orie")
    print("‚ö†Ô∏è  Marquage explicite domaines validit√© et fronti√®res")
    print("")
    
    collector = AnalogyCollector()
    total_collected = collector.save_collection()
    
    print(f"\nüèÜ COLLECTION TERMIN√âE")
    print(f"üìà {total_collected} analogies avec marquage limites int√©gr√©es")
    print(f"üåü PaniniFS enrichi avec m√©canisme analogique s√©curis√©!")
    print(f"‚ö†Ô∏è  Chaque analogie marqu√©e avec fronti√®res explicites!")

if __name__ == "__main__":
    main()
