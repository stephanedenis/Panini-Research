#!/usr/bin/env python3
"""
üöÄ GESTIONNAIRE GOOGLE DRIVE AUTONOME PANINI
==========================================

Gestionnaire autonome pour organisation Google Drive (2TB):
- Cr√©ation structure dossiers Panini
- Upload automatique bibliographie et publications
- Synchronisation bidirectionnelle study pack
- Gestion annotations tablette reMarkable
- 100% autonome via API Google Drive

Structure cible:
/Panini/
‚îú‚îÄ‚îÄ Publications/
‚îÇ   ‚îú‚îÄ‚îÄ Articles_En_Cours/
‚îÇ   ‚îú‚îÄ‚îÄ Articles_Publies/
‚îÇ   ‚îú‚îÄ‚îÄ Livre_Leanpub/
‚îÇ   ‚îî‚îÄ‚îÄ Presentations/
‚îú‚îÄ‚îÄ Bibliographie/
‚îÇ   ‚îú‚îÄ‚îÄ Recherche_Theorique/
‚îÇ   ‚îú‚îÄ‚îÄ Study_Pack_Remarkable/
‚îÇ   ‚îú‚îÄ‚îÄ Papers_Critiques/
‚îÇ   ‚îî‚îÄ‚îÄ References_Panini/
‚îú‚îÄ‚îÄ Recherche/
‚îÇ   ‚îú‚îÄ‚îÄ Audit_Reports/
‚îÇ   ‚îú‚îÄ‚îÄ Criticism_Reports/
‚îÇ   ‚îî‚îÄ‚îÄ Improvement_Logs/
‚îî‚îÄ‚îÄ Annotations/
    ‚îú‚îÄ‚îÄ Remarkable_Exports/
    ‚îî‚îÄ‚îÄ Review_Comments/
"""

import os
import json
import time
from datetime import datetime
from typing import Dict, List, Optional
import pickle
from pathlib import Path
import shutil
import mimetypes

# Google Drive API
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from googleapiclient.http import MediaFileUpload, MediaIoBaseDownload
import io

class AutonomousGoogleDriveManager:
    """Gestionnaire autonome Google Drive pour √©cosyst√®me Panini"""
    
    def __init__(self):
        self.session_id = f"gdrive_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.base_path = "/home/stephane/GitHub/PaniniFS-1"
        self.credentials_path = os.path.join(self.base_path, "gdrive_credentials")
        
        # Scopes Google Drive API
        self.scopes = [
            'https://www.googleapis.com/auth/drive',
            'https://www.googleapis.com/auth/drive.file'
        ]
        
        # Structure dossiers cible
        self.folder_structure = {
            'Panini': {
                'Publications': {
                    'Articles_En_Cours': {},
                    'Articles_Publies': {},
                    'Livre_Leanpub': {},
                    'Presentations': {}
                },
                'Bibliographie': {
                    'Recherche_Theorique': {},
                    'Study_Pack_Remarkable': {},
                    'Papers_Critiques': {},
                    'References_Panini': {}
                },
                'Recherche': {
                    'Audit_Reports': {},
                    'Criticism_Reports': {},
                    'Improvement_Logs': {}
                },
                'Annotations': {
                    'Remarkable_Exports': {},
                    'Review_Comments': {}
                }
            }
        }
        
        self.service = None
        self.folder_ids = {}
        self.upload_log = []
        
    def initialize_google_drive_api(self):
        """Initialise connexion Google Drive API"""
        print("üîë Initialisation Google Drive API...")
        
        creds = None
        token_path = os.path.join(self.credentials_path, "token.pickle")
        credentials_json_path = os.path.join(self.credentials_path, "credentials.json")
        
        # Cr√©er r√©pertoire credentials si inexistant
        os.makedirs(self.credentials_path, exist_ok=True)
        
        # Charger token existant
        if os.path.exists(token_path):
            with open(token_path, 'rb') as token:
                creds = pickle.load(token)
                
        # V√©rifier validit√© et refresh si n√©cessaire
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                print("üîÑ Refresh du token Google Drive...")
                creds.refresh(Request())
            else:
                print("üÜï Nouveau flow d'authentification Google Drive...")
                
                # Cr√©er credentials.json basique si inexistant
                if not os.path.exists(credentials_json_path):
                    self._create_credentials_template(credentials_json_path)
                    print(f"‚ö†Ô∏è Configurez vos credentials dans: {credentials_json_path}")
                    print("   1. Aller √† https://console.developers.google.com/")
                    print("   2. Cr√©er projet et activer Google Drive API")
                    print("   3. Cr√©er credentials OAuth 2.0")
                    print("   4. T√©l√©charger et remplacer credentials.json")
                    return False
                    
                flow = InstalledAppFlow.from_client_secrets_file(
                    credentials_json_path, self.scopes)
                creds = flow.run_local_server(port=0)
                
            # Sauvegarder token
            with open(token_path, 'wb') as token:
                pickle.dump(creds, token)
                
        # Construire service
        try:
            self.service = build('drive', 'v3', credentials=creds)
            print("‚úÖ Google Drive API initialis√©e")
            return True
        except HttpError as error:
            print(f"‚ùå Erreur Google Drive API: {error}")
            return False
            
    def _create_credentials_template(self, path: str):
        """Cr√©e template credentials.json"""
        template = {
            "installed": {
                "client_id": "YOUR_CLIENT_ID.googleusercontent.com",
                "project_id": "panini-filesystem",
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
                "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
                "client_secret": "YOUR_CLIENT_SECRET",
                "redirect_uris": ["urn:ietf:wg:oauth:2.0:oob", "http://localhost"]
            }
        }
        
        with open(path, 'w') as f:
            json.dump(template, f, indent=2)
            
    def create_folder_structure(self):
        """Cr√©e structure compl√®te dossiers Google Drive"""
        print("üìÅ Cr√©ation structure dossiers Google Drive...")
        
        if not self.service:
            print("‚ùå Service Google Drive non initialis√©")
            return False
            
        try:
            # Cr√©er structure r√©cursivement
            self._create_folders_recursive(self.folder_structure, parent_id='root')
            
            # Sauvegarder mapping folder IDs
            self._save_folder_mapping()
            
            print("‚úÖ Structure dossiers cr√©√©e")
            return True
            
        except HttpError as error:
            print(f"‚ùå Erreur cr√©ation dossiers: {error}")
            return False
            
    def _create_folders_recursive(self, structure: Dict, parent_id: str, path: str = ""):
        """Cr√©e dossiers r√©cursivement"""
        for folder_name, sub_structure in structure.items():
            current_path = f"{path}/{folder_name}" if path else folder_name
            
            # V√©rifier si dossier existe d√©j√†
            existing_folder_id = self._find_folder_by_name(folder_name, parent_id)
            
            if existing_folder_id:
                print(f"üìÅ Dossier existant: {current_path}")
                folder_id = existing_folder_id
            else:
                # Cr√©er nouveau dossier
                folder_metadata = {
                    'name': folder_name,
                    'mimeType': 'application/vnd.google-apps.folder',
                    'parents': [parent_id]
                }
                
                folder = self.service.files().create(body=folder_metadata, fields='id').execute()
                folder_id = folder.get('id')
                print(f"‚úÖ Dossier cr√©√©: {current_path}")
                
            # Stocker ID
            self.folder_ids[current_path] = folder_id
            
            # Cr√©er sous-dossiers
            if sub_structure:
                self._create_folders_recursive(sub_structure, folder_id, current_path)
                
    def _find_folder_by_name(self, name: str, parent_id: str) -> Optional[str]:
        """Trouve dossier par nom dans parent sp√©cifi√©"""
        try:
            query = f"name='{name}' and parents in '{parent_id}' and mimeType='application/vnd.google-apps.folder'"
            results = self.service.files().list(q=query, fields="files(id, name)").execute()
            
            files = results.get('files', [])
            if files:
                return files[0]['id']
            return None
            
        except HttpError as error:
            print(f"‚ö†Ô∏è Erreur recherche dossier {name}: {error}")
            return None
            
    def upload_study_pack_to_gdrive(self):
        """Upload study pack remarkable vers Google Drive"""
        print("üìö Upload study pack vers Google Drive...")
        
        study_pack_path = os.path.join(self.base_path, "remarkable_study_pack")
        
        if not os.path.exists(study_pack_path):
            print("‚ùå Study pack non trouv√©")
            return False
            
        # Dossier cible
        target_folder_id = self.folder_ids.get('Panini/Bibliographie/Study_Pack_Remarkable')
        if not target_folder_id:
            print("‚ùå Dossier cible non trouv√©")
            return False
            
        # Upload r√©cursif
        success_count = 0
        total_count = 0
        
        for root, dirs, files in os.walk(study_pack_path):
            for file in files:
                file_path = os.path.join(root, file)
                relative_path = os.path.relpath(file_path, study_pack_path)
                
                total_count += 1
                
                # Cr√©er sous-dossiers si n√©cessaire
                dir_structure = os.path.dirname(relative_path)
                if dir_structure:
                    current_folder_id = self._ensure_folder_path(dir_structure, target_folder_id)
                else:
                    current_folder_id = target_folder_id
                    
                # Upload fichier
                if self._upload_file(file_path, file, current_folder_id):
                    success_count += 1
                    
        print(f"üìä Upload termin√©: {success_count}/{total_count} fichiers")
        return success_count > 0
        
    def _ensure_folder_path(self, path: str, parent_id: str) -> str:
        """Assure existence chemin dossiers"""
        folders = path.split('/')
        current_parent = parent_id
        
        for folder_name in folders:
            # Chercher dossier existant
            existing_id = self._find_folder_by_name(folder_name, current_parent)
            
            if existing_id:
                current_parent = existing_id
            else:
                # Cr√©er dossier
                folder_metadata = {
                    'name': folder_name,
                    'mimeType': 'application/vnd.google-apps.folder',
                    'parents': [current_parent]
                }
                
                folder = self.service.files().create(body=folder_metadata, fields='id').execute()
                current_parent = folder.get('id')
                
        return current_parent
        
    def _upload_file(self, file_path: str, file_name: str, parent_id: str) -> bool:
        """Upload fichier vers Google Drive"""
        try:
            # D√©terminer mime type
            mime_type, _ = mimetypes.guess_type(file_path)
            if not mime_type:
                mime_type = 'application/octet-stream'
                
            # Metadata fichier
            file_metadata = {
                'name': file_name,
                'parents': [parent_id]
            }
            
            # Media upload
            media = MediaFileUpload(file_path, mimetype=mime_type, resumable=True)
            
            # V√©rifier si fichier existe d√©j√†
            existing_file_id = self._find_file_by_name(file_name, parent_id)
            
            if existing_file_id:
                # Mettre √† jour fichier existant
                file = self.service.files().update(
                    fileId=existing_file_id,
                    media_body=media
                ).execute()
                print(f"üîÑ Fichier mis √† jour: {file_name}")
            else:
                # Cr√©er nouveau fichier
                file = self.service.files().create(
                    body=file_metadata,
                    media_body=media,
                    fields='id'
                ).execute()
                print(f"üì§ Fichier upload√©: {file_name}")
                
            # Logger upload
            self.upload_log.append({
                'timestamp': datetime.now().isoformat(),
                'file_name': file_name,
                'file_path': file_path,
                'gdrive_id': file.get('id'),
                'action': 'update' if existing_file_id else 'create'
            })
            
            return True
            
        except HttpError as error:
            print(f"‚ùå Erreur upload {file_name}: {error}")
            return False
            
    def _find_file_by_name(self, name: str, parent_id: str) -> Optional[str]:
        """Trouve fichier par nom dans parent"""
        try:
            query = f"name='{name}' and parents in '{parent_id}'"
            results = self.service.files().list(q=query, fields="files(id, name)").execute()
            
            files = results.get('files', [])
            if files:
                return files[0]['id']
            return None
            
        except HttpError as error:
            print(f"‚ö†Ô∏è Erreur recherche fichier {name}: {error}")
            return None
            
    def upload_publications_to_gdrive(self):
        """Upload publications en cours vers Google Drive"""
        print("üìù Upload publications vers Google Drive...")
        
        publications_uploaded = 0
        
        # Publications existantes √† uploader
        publication_files = [
            {'local': 'README.md', 'gdrive_path': 'Panini/Publications/Articles_En_Cours', 'name': 'README_PaniniFS.md'},
            {'local': 'EXTERNALISATION-CAMPING-STRATEGY.md', 'gdrive_path': 'Panini/Publications/Articles_En_Cours', 'name': 'Strategy_Externalisation.md'},
            {'local': 'panini_conceptual_audit_report.json', 'gdrive_path': 'Panini/Recherche/Audit_Reports', 'name': 'Conceptual_Audit_Latest.json'},
            {'local': 'ecosystem_coherence_final_report.json', 'gdrive_path': 'Panini/Recherche/Audit_Reports', 'name': 'Ecosystem_Coherence_Final.json'}
        ]
        
        for pub in publication_files:
            local_path = os.path.join(self.base_path, pub['local'])
            
            if os.path.exists(local_path):
                folder_id = self.folder_ids.get(pub['gdrive_path'])
                if folder_id:
                    if self._upload_file(local_path, pub['name'], folder_id):
                        publications_uploaded += 1
                        
        # Upload dossier publications review complet
        pub_review_path = os.path.join(self.base_path, "remarkable_study_pack/publications_review")
        if os.path.exists(pub_review_path):
            target_folder_id = self.folder_ids.get('Panini/Publications/Articles_En_Cours')
            if target_folder_id:
                for file in os.listdir(pub_review_path):
                    file_path = os.path.join(pub_review_path, file)
                    if os.path.isfile(file_path):
                        if self._upload_file(file_path, f"Review_{file}", target_folder_id):
                            publications_uploaded += 1
                            
        print(f"üìä Publications upload√©es: {publications_uploaded}")
        return publications_uploaded > 0
        
    def setup_remarkable_sync_workflow(self):
        """Configure workflow synchronisation tablette reMarkable"""
        print("üì± Configuration sync reMarkable...")
        
        # Instructions sync reMarkable
        sync_instructions = {
            'workflow_type': 'remarkable_tablet_sync',
            'description': 'Synchronisation bidirectionnelle tablette reMarkable',
            'steps': [
                '1. T√©l√©charger PDFs depuis Google Drive/Bibliographie/Study_Pack_Remarkable/',
                '2. Transf√©rer vers reMarkable via reMarkable Desktop ou cloud',
                '3. Annoter et r√©viser sur tablette',
                '4. Exporter annotations depuis reMarkable',
                '5. Upload annotations vers Google Drive/Annotations/Remarkable_Exports/',
                '6. Traitement automatique commentaires pour am√©lioration'
            ],
            'automation': {
                'download_pdfs': 'Script automatique download nouveaux PDFs',
                'monitor_exports': 'Surveillance dossier exports reMarkable',
                'process_annotations': 'Extraction et traitement commentaires'
            },
            'google_drive_folders': {
                'source_bibliography': 'Panini/Bibliographie/Study_Pack_Remarkable/',
                'annotation_exports': 'Panini/Annotations/Remarkable_Exports/',
                'review_comments': 'Panini/Annotations/Review_Comments/'
            }
        }
        
        # Sauvegarder instructions
        sync_path = os.path.join(self.base_path, "remarkable_sync_workflow.json")
        with open(sync_path, 'w', encoding='utf-8') as f:
            json.dump(sync_instructions, f, indent=2, ensure_ascii=False)
            
        # Upload vers Google Drive
        workflow_folder_id = self.folder_ids.get('Panini/Annotations')
        if workflow_folder_id:
            self._upload_file(sync_path, "remarkable_sync_workflow.json", workflow_folder_id)
            
        print("‚úÖ Workflow reMarkable configur√©")
        return True
        
    def create_bibliography_pdfs(self):
        """Cr√©e PDFs optimis√©s pour tablette reMarkable"""
        print("üìÑ Cr√©ation PDFs bibliographie...")
        
        # Utiliser script existant pour g√©n√©rer bibliographie
        try:
            import subprocess
            
            # Ex√©cuter g√©n√©rateur bibliographie avec option PDF
            result = subprocess.run([
                'python3',
                os.path.join(self.base_path, 'Copilotage/scripts/generate_remarkable_bibliography.py'),
                '--format', 'pdf',
                '--tablet-optimized'
            ], capture_output=True, text=True, cwd=self.base_path)
            
            if result.returncode == 0:
                print("‚úÖ PDFs bibliographie g√©n√©r√©s")
                return True
            else:
                print(f"‚ö†Ô∏è Erreur g√©n√©ration PDFs: {result.stderr}")
                return False
                
        except Exception as e:
            print(f"‚ùå Erreur cr√©ation PDFs: {e}")
            return False
            
    def monitor_gdrive_space_usage(self):
        """Surveille utilisation espace Google Drive"""
        print("üíæ V√©rification espace Google Drive...")
        
        try:
            about = self.service.about().get(fields="storageQuota").execute()
            storage = about.get('storageQuota', {})
            
            # Calculs espace
            limit = int(storage.get('limit', 0))
            usage = int(storage.get('usage', 0))
            
            # Conversion en unit√©s lisibles
            limit_gb = limit / (1024**3) if limit > 0 else 0
            usage_gb = usage / (1024**3)
            available_gb = limit_gb - usage_gb if limit > 0 else float('inf')
            
            usage_percent = (usage_gb / limit_gb * 100) if limit_gb > 0 else 0
            
            print(f"üìä Espace Google Drive:")
            print(f"   üíæ Utilis√©: {usage_gb:.2f} GB")
            print(f"   üì¶ Total: {limit_gb:.2f} GB")
            print(f"   üÜì Disponible: {available_gb:.2f} GB")
            print(f"   üìà Pourcentage: {usage_percent:.1f}%")
            
            # Alertes
            if usage_percent > 90:
                print("üö® ALERTE: Espace presque plein!")
            elif usage_percent > 75:
                print("‚ö†Ô∏è Attention: Plus de 75% utilis√©")
                
            return {
                'total_gb': limit_gb,
                'used_gb': usage_gb,
                'available_gb': available_gb,
                'usage_percent': usage_percent
            }
            
        except HttpError as error:
            print(f"‚ùå Erreur v√©rification espace: {error}")
            return None
            
    def autonomous_sync_cycle(self):
        """Cycle complet synchronisation autonome"""
        print("üöÄ CYCLE SYNCHRONISATION AUTONOME GOOGLE DRIVE")
        print("=" * 60)
        
        success_steps = 0
        total_steps = 7
        
        # 1. Initialisation API
        if self.initialize_google_drive_api():
            success_steps += 1
            
        # 2. Cr√©ation structure
        if self.create_folder_structure():
            success_steps += 1
            
        # 3. Monitoring espace
        space_info = self.monitor_gdrive_space_usage()
        if space_info:
            success_steps += 1
            
        # 4. Cr√©ation PDFs bibliographie
        if self.create_bibliography_pdfs():
            success_steps += 1
            
        # 5. Upload study pack
        if self.upload_study_pack_to_gdrive():
            success_steps += 1
            
        # 6. Upload publications
        if self.upload_publications_to_gdrive():
            success_steps += 1
            
        # 7. Configuration workflow reMarkable
        if self.setup_remarkable_sync_workflow():
            success_steps += 1
            
        # Rapport final
        self._generate_sync_report(success_steps, total_steps, space_info)
        
        print(f"\nüéØ SYNCHRONISATION TERMIN√âE: {success_steps}/{total_steps} √©tapes r√©ussies")
        
        return success_steps == total_steps
        
    def _save_folder_mapping(self):
        """Sauvegarde mapping IDs dossiers"""
        mapping_path = os.path.join(self.credentials_path, "folder_mapping.json")
        
        with open(mapping_path, 'w') as f:
            json.dump(self.folder_ids, f, indent=2)
            
        print(f"üíæ Mapping dossiers sauvegard√©: {mapping_path}")
        
    def _generate_sync_report(self, success_steps: int, total_steps: int, space_info: Optional[Dict]):
        """G√©n√®re rapport synchronisation"""
        report = {
            'session_id': self.session_id,
            'timestamp': datetime.now().isoformat(),
            'sync_summary': {
                'success_steps': success_steps,
                'total_steps': total_steps,
                'success_rate': f"{success_steps/total_steps*100:.1f}%"
            },
            'folder_structure_created': len(self.folder_ids),
            'files_uploaded': len(self.upload_log),
            'gdrive_space': space_info,
            'folder_ids': self.folder_ids,
            'upload_log': self.upload_log,
            'remarkable_workflow': {
                'configured': True,
                'sync_folders': {
                    'bibliography_source': 'Panini/Bibliographie/Study_Pack_Remarkable/',
                    'annotations_target': 'Panini/Annotations/Remarkable_Exports/'
                }
            },
            'next_actions': [
                'T√©l√©charger PDFs depuis Google Drive vers reMarkable',
                'Configurer sync automatique annotations',
                'R√©viser publications sur tablette',
                'Uploader commentaires pour am√©lioration continue'
            ]
        }
        
        # Sauvegarde rapport
        report_path = os.path.join(self.base_path, f"gdrive_sync_report_{self.session_id}.json")
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
            
        # Rapport lisible
        self._print_sync_summary(report)
        
        print(f"üìä Rapport complet: {report_path}")
        
    def _print_sync_summary(self, report: Dict):
        """Affiche r√©sum√© synchronisation"""
        print("\n" + "="*60)
        print("üìä R√âSUM√â SYNCHRONISATION GOOGLE DRIVE")
        print("="*60)
        
        # Succ√®s
        summary = report['sync_summary']
        print(f"\n‚úÖ Taux de succ√®s: {summary['success_rate']}")
        print(f"üìÅ Dossiers cr√©√©s: {report['folder_structure_created']}")
        print(f"üì§ Fichiers upload√©s: {report['files_uploaded']}")
        
        # Espace
        if report.get('gdrive_space'):
            space = report['gdrive_space']
            print(f"üíæ Espace utilis√©: {space['used_gb']:.2f}/{space['total_gb']:.2f} GB ({space['usage_percent']:.1f}%)")
            
        # Structure cr√©√©e
        print(f"\nüìÅ STRUCTURE GOOGLE DRIVE:")
        print("   üìÇ Panini/")
        print("      üìÇ Publications/")
        print("         üìÑ Articles_En_Cours/ (r√©vision tablette)")
        print("         üìÑ Articles_Publies/")
        print("         üìÑ Livre_Leanpub/")
        print("      üìÇ Bibliographie/")
        print("         üìö Study_Pack_Remarkable/ (PDFs tablette)")
        print("         üìö Recherche_Theorique/")
        print("      üìÇ Recherche/")
        print("         üìä Audit_Reports/")
        print("         üî• Criticism_Reports/")
        print("      üìÇ Annotations/")
        print("         ‚úèÔ∏è Remarkable_Exports/ (vos annotations)")
        print("         üí¨ Review_Comments/")
        
        # Actions suivantes
        print(f"\nüöÄ PROCHAINES ACTIONS:")
        for action in report['next_actions']:
            print(f"   ‚Ä¢ {action}")
            
        print("\n" + "="*60)

def main():
    """Fonction principale"""
    print("üöÄ GESTIONNAIRE GOOGLE DRIVE AUTONOME - PANINI")
    print("Objectif: Organisation compl√®te Google Drive (2TB)")
    print("Mode: 100% autonome avec API Google Drive")
    print("=" * 60)
    
    try:
        manager = AutonomousGoogleDriveManager()
        success = manager.autonomous_sync_cycle()
        
        if success:
            print("üéâ Synchronisation Google Drive r√©ussie!")
            print("üì± Votre tablette reMarkable peut maintenant acc√©der √† la bibliographie")
            print("üí¨ Vos annotations seront automatiquement int√©gr√©es")
        else:
            print("‚ö†Ô∏è Synchronisation partiellement r√©ussie - Voir rapport pour d√©tails")
            
    except Exception as e:
        print(f"‚ùå Erreur critique: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
