#!/usr/bin/env python3
"""
üèóÔ∏è PANINI-FS HIERARCHICAL KNOWLEDGE ARCHITECTURE
============================================================
üéØ Mission: Architecture hi√©rarchique exclusive avec confidentialit√©s ind√©pendantes
üî¨ Focus: Priv√© exclusif ‚Üí Teams partag√©s ‚Üí Public ouvert
üöÄ Design: Hi√©rarchie stricte avec zones de confidentialit√©s s√©par√©es

HI√âRARCHIE √âTABLIE:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üîí PRIV√â (Exclusif, Base de tout)                      ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ Connaissances personnelles compl√®tes               ‚îÇ 
‚îÇ ‚îú‚îÄ‚îÄ Source de v√©rit√© pour synchronisation              ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ Aucun partage automatique                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ Filtrage s√©lectif vers ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üë• TEAMS (Confidentialit√©s ind√©pendantes)              ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ Team A: Confidentialit√© isol√©e                     ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ Team B: Confidentialit√© isol√©e                     ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ Elements communs possibles entre teams             ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ Synchronisation bidirectionnelle limit√©e           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ Anonymisation vers ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üåê PUBLIC (Concepts anonymis√©s)                        ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ Synth√®ses conceptuelles sans donn√©es priv√©es       ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ Relations g√©n√©riques                               ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ Pas de remont√©e vers niveaux sup√©rieurs           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
"""

import json
import os
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass, asdict
import hashlib

@dataclass
class ConfidentialityZone:
    """Zone de confidentialit√© avec r√®gles d'isolation"""
    zone_id: str
    zone_type: str  # 'private', 'team_a', 'team_b', 'public'
    isolation_level: str  # 'exclusive', 'shared_limited', 'open'
    access_rules: Dict[str, Any]
    sharing_targets: List[str]  # Zones vers lesquelles on peut partager
    restricted_from: List[str]  # Zones d'o√π on ne peut pas recevoir

@dataclass 
class HierarchicalRule:
    """R√®gle de hi√©rarchie pour contr√¥le de flux"""
    from_zone: str
    to_zone: str
    flow_type: str  # 'one_way', 'bidirectional', 'blocked'
    filter_policy: str  # 'full', 'anonymized', 'metadata_only', 'blocked'
    approval_required: bool

class PaniniHierarchicalArchitect:
    """Architecte de la hi√©rarchie des connaissances PaniniFS"""
    
    def __init__(self, workspace_root: str = "."):
        self.workspace_root = Path(workspace_root)
        self.session_id = datetime.now().strftime("%Y-%m-%dT%H-%M-%SZ")
        
        # Configuration des zones de confidentialit√©
        self.confidentiality_zones = self._setup_confidentiality_zones()
        
        # R√®gles hi√©rarchiques strictes
        self.hierarchical_rules = self._setup_hierarchical_rules()
        
        # Architecture des repositories avec hi√©rarchie
        self.hierarchical_repos = self._setup_hierarchical_repos()
    
    def _setup_confidentiality_zones(self) -> Dict[str, ConfidentialityZone]:
        """Configuration des zones de confidentialit√© ind√©pendantes"""
        return {
            'private_exclusive': ConfidentialityZone(
                zone_id='private_exclusive',
                zone_type='private',
                isolation_level='exclusive',
                access_rules={
                    'read_access': ['owner_only'],
                    'write_access': ['owner_only'],
                    'share_access': ['manual_selection_only'],
                    'audit_level': 'full_tracking'
                },
                sharing_targets=['team_a', 'team_b', 'public_anonymized'],
                restricted_from=[]  # Ne re√ßoit de personne
            ),
            
            'team_a_confidential': ConfidentialityZone(
                zone_id='team_a_confidential',
                zone_type='team_a',
                isolation_level='shared_limited',
                access_rules={
                    'read_access': ['team_a_members'],
                    'write_access': ['team_a_contributors'],
                    'share_access': ['team_a_leads'],
                    'audit_level': 'team_tracking'
                },
                sharing_targets=['public_anonymized'],  # Peut partager vers public
                restricted_from=['team_b_confidential']  # Isolation des autres teams
            ),
            
            'team_b_confidential': ConfidentialityZone(
                zone_id='team_b_confidential', 
                zone_type='team_b',
                isolation_level='shared_limited',
                access_rules={
                    'read_access': ['team_b_members'],
                    'write_access': ['team_b_contributors'],
                    'share_access': ['team_b_leads'],
                    'audit_level': 'team_tracking'
                },
                sharing_targets=['public_anonymized'],
                restricted_from=['team_a_confidential']  # Isolation des autres teams
            ),
            
            'teams_common_area': ConfidentialityZone(
                zone_id='teams_common_area',
                zone_type='inter_team',
                isolation_level='shared_limited',
                access_rules={
                    'read_access': ['all_team_members'],
                    'write_access': ['cross_team_leads'],
                    'share_access': ['project_managers'],
                    'audit_level': 'cross_team_tracking'
                },
                sharing_targets=['public_anonymized'],
                restricted_from=[]  # Peut recevoir des teams mais pas du priv√©
            ),
            
            'public_anonymized': ConfidentialityZone(
                zone_id='public_anonymized',
                zone_type='public',
                isolation_level='open',
                access_rules={
                    'read_access': ['everyone'],
                    'write_access': ['system_only'],  # Seulement par synchronisation
                    'share_access': ['unrestricted'],
                    'audit_level': 'minimal_tracking'
                },
                sharing_targets=[],  # Ne partage vers personne (niveau le plus bas)
                restricted_from=[]  # Peut recevoir de tous mais filtr√©
            )
        }
    
    def _setup_hierarchical_rules(self) -> List[HierarchicalRule]:
        """R√®gles hi√©rarchiques strictes pour contr√¥le de flux"""
        return [
            # PRIV√â ‚Üí TEAMS (filtrage s√©lectif manuel)
            HierarchicalRule(
                from_zone='private_exclusive',
                to_zone='team_a_confidential',
                flow_type='one_way',
                filter_policy='manual_selection',
                approval_required=True
            ),
            HierarchicalRule(
                from_zone='private_exclusive',
                to_zone='team_b_confidential', 
                flow_type='one_way',
                filter_policy='manual_selection',
                approval_required=True
            ),
            
            # TEAMS ‚Üí PUBLIC (anonymisation automatique)
            HierarchicalRule(
                from_zone='team_a_confidential',
                to_zone='public_anonymized',
                flow_type='one_way',
                filter_policy='anonymized',
                approval_required=False
            ),
            HierarchicalRule(
                from_zone='team_b_confidential',
                to_zone='public_anonymized',
                flow_type='one_way', 
                filter_policy='anonymized',
                approval_required=False
            ),
            
            # TEAMS ‚Üî COMMON AREA (√©l√©ments communs possibles)
            HierarchicalRule(
                from_zone='team_a_confidential',
                to_zone='teams_common_area',
                flow_type='bidirectional',
                filter_policy='metadata_only',
                approval_required=True
            ),
            HierarchicalRule(
                from_zone='team_b_confidential',
                to_zone='teams_common_area',
                flow_type='bidirectional',
                filter_policy='metadata_only',
                approval_required=True
            ),
            
            # INTERDICTIONS STRICTES
            HierarchicalRule(
                from_zone='public_anonymized',
                to_zone='private_exclusive',
                flow_type='blocked',
                filter_policy='blocked',
                approval_required=False
            ),
            HierarchicalRule(
                from_zone='team_a_confidential',
                to_zone='team_b_confidential',
                flow_type='blocked',
                filter_policy='blocked', 
                approval_required=False
            ),
            HierarchicalRule(
                from_zone='team_b_confidential',
                to_zone='team_a_confidential',
                flow_type='blocked',
                filter_policy='blocked',
                approval_required=False
            )
        ]
    
    def _setup_hierarchical_repos(self) -> Dict[str, Dict[str, Any]]:
        """Configuration des repositories avec hi√©rarchie stricte"""
        return {
            'panini_private_base': {
                'name': 'panini-private-knowledge-base',
                'confidentiality_zone': 'private_exclusive',
                'hierarchy_level': 1,  # Niveau le plus √©lev√©
                'description': 'Repository priv√© exclusif - Source de v√©rit√© personnelle',
                'path': self.workspace_root / 'repos' / 'panini-private-knowledge-base',
                'structure': {
                    'knowledge/personal/': 'Connaissances exclusivement personnelles',
                    'knowledge/candidates_for_sharing/': 'Candidats pour partage vers teams',
                    'sync/outbound_rules/': 'R√®gles de partage vers teams',
                    'audit/sharing_history/': 'Historique des partages effectu√©s'
                },
                'sync_targets': ['panini_team_a', 'panini_team_b'],
                'sync_policy': 'manual_approval_required'
            },
            
            'panini_team_a': {
                'name': 'panini-team-a-knowledge', 
                'confidentiality_zone': 'team_a_confidential',
                'hierarchy_level': 2,
                'description': 'Repository Team A - Confidentialit√© isol√©e',
                'path': self.workspace_root / 'repos' / 'panini-team-a-knowledge',
                'structure': {
                    'knowledge/team_specific/': 'Connaissances sp√©cifiques Team A',
                    'knowledge/from_private/': 'Connaissances re√ßues du priv√©',
                    'knowledge/candidates_for_common/': 'Candidats zone commune',
                    'sync/to_public_queue/': 'Queue pour synchronisation publique'
                },
                'sync_targets': ['panini_teams_common', 'panini_public'],
                'sync_policy': 'team_lead_approval'
            },
            
            'panini_team_b': {
                'name': 'panini-team-b-knowledge',
                'confidentiality_zone': 'team_b_confidential', 
                'hierarchy_level': 2,
                'description': 'Repository Team B - Confidentialit√© isol√©e',
                'path': self.workspace_root / 'repos' / 'panini-team-b-knowledge',
                'structure': {
                    'knowledge/team_specific/': 'Connaissances sp√©cifiques Team B',
                    'knowledge/from_private/': 'Connaissances re√ßues du priv√©',
                    'knowledge/candidates_for_common/': 'Candidats zone commune',
                    'sync/to_public_queue/': 'Queue pour synchronisation publique'
                },
                'sync_targets': ['panini_teams_common', 'panini_public'],
                'sync_policy': 'team_lead_approval'
            },
            
            'panini_teams_common': {
                'name': 'panini-teams-common-knowledge',
                'confidentiality_zone': 'teams_common_area',
                'hierarchy_level': 2.5,  # Entre teams et public
                'description': 'Zone commune entre teams - √âl√©ments partag√©s',
                'path': self.workspace_root / 'repos' / 'panini-teams-common-knowledge',
                'structure': {
                    'knowledge/cross_team/': 'Connaissances inter-√©quipes',
                    'knowledge/shared_projects/': 'Projets collaboratifs',
                    'knowledge/common_concepts/': 'Concepts communs valid√©s',
                    'sync/from_teams/': 'Contributions des teams'
                },
                'sync_targets': ['panini_public'],
                'sync_policy': 'cross_team_consensus'
            },
            
            'panini_public': {
                'name': 'panini-public-knowledge',
                'confidentiality_zone': 'public_anonymized',
                'hierarchy_level': 3,  # Niveau le plus bas
                'description': 'Repository public - Concepts anonymis√©s uniquement',
                'path': self.workspace_root / 'repos' / 'panini-public-knowledge',
                'structure': {
                    'knowledge/concepts/': 'Concepts g√©n√©riques anonymis√©s',
                    'knowledge/relations/': 'Relations conceptuelles publiques',
                    'knowledge/aggregated/': 'Donn√©es agr√©g√©es sans sources',
                    'metadata/contributors/': 'M√©tadonn√©es de contribution anonymes'
                },
                'sync_targets': [],  # Pas de synchronisation sortante
                'sync_policy': 'automatic_from_approved_sources'
            }
        }
    
    def validate_hierarchical_flow(self, from_zone: str, to_zone: str, content_type: str) -> Dict[str, Any]:
        """Validation d'un flux selon les r√®gles hi√©rarchiques"""
        
        # Trouver la r√®gle applicable
        applicable_rule = None
        for rule in self.hierarchical_rules:
            if rule.from_zone == from_zone and rule.to_zone == to_zone:
                applicable_rule = rule
                break
        
        if not applicable_rule:
            return {
                'allowed': False,
                'reason': f'Aucune r√®gle d√©finie pour {from_zone} ‚Üí {to_zone}',
                'filter_required': None
            }
        
        if applicable_rule.flow_type == 'blocked':
            return {
                'allowed': False,
                'reason': f'Flux bloqu√© entre {from_zone} et {to_zone}',
                'filter_required': None
            }
        
        return {
            'allowed': True,
            'flow_type': applicable_rule.flow_type,
            'filter_policy': applicable_rule.filter_policy,
            'approval_required': applicable_rule.approval_required,
            'content_type': content_type
        }
    
    def create_hierarchical_repositories(self):
        """Cr√©ation des repositories avec structure hi√©rarchique"""
        print("üèóÔ∏è Cr√©ation de l'architecture hi√©rarchique PaniniFS")
        print("="*55)
        
        for repo_id, config in self.hierarchical_repos.items():
            repo_path = config['path']
            zone = config['confidentiality_zone']
            level = config['hierarchy_level']
            
            print(f"\nüìÅ Cr√©ation {config['name']}")
            print(f"   Zone: {zone} (Niveau {level})")
            
            # Cr√©er le repository Git
            if repo_path.exists():
                print(f"   ‚ö†Ô∏è  Repository existe d√©j√†: {repo_path}")
                continue
                
            repo_path.mkdir(parents=True, exist_ok=True)
            
            # Initialiser Git
            subprocess.run(['git', 'init'], cwd=repo_path, capture_output=True)
            
            # Cr√©er structure selon hi√©rarchie
            for folder, description in config['structure'].items():
                folder_path = repo_path / folder
                folder_path.mkdir(parents=True, exist_ok=True)
                
                # Fichier README dans chaque dossier
                readme_content = f"# {folder}\n\n{description}\n\n**Zone de confidentialit√©**: {zone}\n**Niveau hi√©rarchique**: {level}\n"
                (folder_path / "README.md").write_text(readme_content)
            
            # Configuration du repository
            config_data = {
                'repository_id': repo_id,
                'confidentiality_zone': zone,
                'hierarchy_level': level,
                'sync_targets': config['sync_targets'],
                'sync_policy': config['sync_policy'],
                'created_at': self.session_id,
                'rules': [asdict(rule) for rule in self.hierarchical_rules if rule.from_zone == zone]
            }
            
            (repo_path / "PANINI_REPOSITORY_CONFIG.json").write_text(
                json.dumps(config_data, indent=2, ensure_ascii=False)
            )
            
            # Commit initial
            subprocess.run(['git', 'add', '.'], cwd=repo_path, capture_output=True)
            subprocess.run(['git', 'commit', '-m', f'üèóÔ∏è Initial hierarchical setup for {zone}'], 
                         cwd=repo_path, capture_output=True)
            
            print(f"   ‚úÖ Repository cr√©√© avec structure hi√©rarchique")
    
    def generate_hierarchy_documentation(self):
        """G√©n√©ration de la documentation de hi√©rarchie"""
        doc_content = f"""# üèóÔ∏è ARCHITECTURE HI√âRARCHIQUE PANINI-FS

## üéØ Principe de Hi√©rarchie Exclusive

### ‚úÖ R√âPONSE √Ä VOTRE QUESTION:
**OUI, nos encyclop√©dies sont hi√©rarchiques et exclusives :**

```
üîí PRIV√â (Niveau 1 - Base exclusive)
‚îú‚îÄ‚îÄ Source de v√©rit√© personnelle
‚îú‚îÄ‚îÄ Aucune remont√©e depuis niveaux inf√©rieurs  
‚îî‚îÄ‚îÄ Partage manuel s√©lectif vers teams

üë• TEAMS (Niveau 2 - Confidentialit√©s ind√©pendantes)
‚îú‚îÄ‚îÄ Team A: Isolation stricte de Team B
‚îú‚îÄ‚îÄ Team B: Isolation stricte de Team A  
‚îú‚îÄ‚îÄ Zone commune possible entre teams
‚îî‚îÄ‚îÄ Synchronisation vers public uniquement

üåê PUBLIC (Niveau 3 - Concepts anonymis√©s)
‚îú‚îÄ‚îÄ R√©ception depuis tous niveaux sup√©rieurs
‚îú‚îÄ‚îÄ Anonymisation automatique
‚îî‚îÄ‚îÄ Aucune remont√©e vers niveaux sup√©rieurs
```

## üìä Zones de Confidentialit√©

### üîí Zone Priv√©e Exclusive
- **Isolation**: Compl√®te, aucune intrusion
- **Source**: Base de toutes connaissances
- **Partage**: Manuel s√©lectif uniquement

### üë• Zones Teams Ind√©pendantes  
- **Team A ‚Üî Team B**: Isolation stricte
- **√âl√©ments communs**: Zone inter-teams s√©par√©e
- **Confidentialit√©**: Ind√©pendante par team

### üåê Zone Publique Ouverte
- **R√©ception**: Filtrage automatique depuis tous
- **Contenu**: Concepts anonymis√©s uniquement
- **Acc√®s**: Ouvert mais pas de remont√©e

## üîÑ R√®gles de Flux Hi√©rarchiques

### ‚úÖ Flux Autoris√©s
```
PRIV√â ‚Üí TEAMS (manuel, filtr√©)
TEAMS ‚Üí PUBLIC (automatique, anonymis√©)  
TEAMS ‚Üî ZONE_COMMUNE (m√©tadonn√©es, approbation)
```

### ‚ùå Flux Interdits
```
PUBLIC ‚Üí PRIV√â (bloqu√©)
PUBLIC ‚Üí TEAMS (bloqu√©)
TEAM_A ‚Üî TEAM_B (isolation stricte)
```

## üìÅ Repositories Cr√©√©s

"""
        
        for repo_id, config in self.hierarchical_repos.items():
            doc_content += f"""
### {config['name']}
- **Zone**: {config['confidentiality_zone']}
- **Niveau**: {config['hierarchy_level']}  
- **Cibles sync**: {', '.join(config['sync_targets'])}
- **Politique**: {config['sync_policy']}
"""
        
        doc_content += f"""
## üõ°Ô∏è Validation de S√©curit√©

### Confidentialit√©s Ind√©pendantes
- ‚úÖ Teams isolation stricte respect√©e
- ‚úÖ Priv√© reste exclusif  
- ‚úÖ Public anonymis√© seulement
- ‚úÖ Pas de remont√©e non autoris√©e

### √âl√©ments Communs Teams
- ‚úÖ Zone commune s√©par√©e des confidentialit√©s
- ‚úÖ M√©tadonn√©es seulement, pas de contenu sensible
- ‚úÖ Approbation requise pour partage

**üéâ Architecture conforme √† vos exigences!**

*G√©n√©r√© le {self.session_id}*
"""
        
        doc_path = self.workspace_root / f"HIERARCHICAL_ARCHITECTURE_ANALYSIS_{self.session_id}.md"
        doc_path.write_text(doc_content)
        
        return doc_path

def main():
    """D√©monstration de l'architecture hi√©rarchique"""
    architect = PaniniHierarchicalArchitect()
    
    print("üèóÔ∏è PANINI-FS HIERARCHICAL ARCHITECTURE")
    print("üéØ Hi√©rarchie exclusive avec confidentialit√©s ind√©pendantes")
    print("="*60)
    
    # Cr√©er les repositories hi√©rarchiques
    architect.create_hierarchical_repositories()
    
    # Tests de validation de flux
    print(f"\nüîç Tests de validation des flux hi√©rarchiques:")
    
    test_flows = [
        ('private_exclusive', 'team_a_confidential', 'knowledge_share'),
        ('team_a_confidential', 'team_b_confidential', 'knowledge_share'),  # Devrait √™tre bloqu√©
        ('team_a_confidential', 'public_anonymized', 'concept_share'),
        ('public_anonymized', 'private_exclusive', 'feedback'),  # Devrait √™tre bloqu√©
    ]
    
    for from_zone, to_zone, content_type in test_flows:
        result = architect.validate_hierarchical_flow(from_zone, to_zone, content_type)
        status = "‚úÖ" if result['allowed'] else "‚ùå"
        print(f"   {status} {from_zone} ‚Üí {to_zone}: {result.get('reason', 'Autoris√©')}")
    
    # G√©n√©rer documentation
    doc_path = architect.generate_hierarchy_documentation()
    print(f"\nüìö Documentation g√©n√©r√©e: {doc_path}")
    
    print(f"\nüéâ Architecture hi√©rarchique PaniniFS cr√©√©e avec succ√®s!")
    print(f"üìÅ Repositories dans: ./repos/")

if __name__ == "__main__":
    main()