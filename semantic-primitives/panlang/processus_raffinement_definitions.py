#!/usr/bin/env python3
"""
PROCESSUS DE RAFFINEMENT D√âFINITIONS S√âMANTIQUES v3.0
===================================================

Pipeline intelligent pour corriger les ambigu√Øt√©s d√©tect√©es et enrichir
les d√©finitions avec dimensions contextuelles, connotatives et pragmatiques.

Bas√© sur l'analyse des 154 conflits et suggestions automatiques g√©n√©r√©es.
"""

import json
import numpy as np
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from collections import defaultdict, Counter
import time
import os

@dataclass
class RefinedConcept:
    """Concept raffin√© avec d√©finition enrichie"""
    original_name: str
    refined_atoms: List[str]
    contextual_dimensions: Dict[str, Any]
    connotative_aspects: Dict[str, float]
    pragmatic_constraints: List[str]
    usage_patterns: Dict[str, List[str]]
    confidence_score: float
    linguistic_justification: str

@dataclass
class RefinementOperation:
    """Op√©ration de raffinement appliqu√©e"""
    concept_name: str
    operation_type: str  # 'add_dimension', 'replace_atoms', 'split_concept', 'merge_concepts'
    before_state: Dict[str, Any]
    after_state: Dict[str, Any]
    rationale: str
    validation_tests: List[str]

class DefinitionRefinementProcessor:
    """Processeur principal de raffinement des d√©finitions"""
    
    def __init__(self, ambiguity_report_path: str, detection_report_path: str):
        self.ambiguity_report_path = ambiguity_report_path
        self.detection_report_path = detection_report_path
        
        # Charger donn√©es d'analyse
        self.ambiguity_data = self._load_json_report(ambiguity_report_path)
        self.detection_data = self._load_json_report(detection_report_path)
        
        # Donn√©es raffinement
        self.current_concepts = self._extract_current_concepts()
        self.conflict_priorities = self._extract_conflict_priorities()
        
        # Biblioth√®ques de raffinement
        self.contextual_dimensions_db = self._build_contextual_dimensions()
        self.connotative_profiles_db = self._build_connotative_profiles()
        self.pragmatic_constraints_db = self._build_pragmatic_constraints()
        
        print(f"üîß Processeur raffinement initialis√©")
        print(f"üìä {len(self.current_concepts)} concepts √† traiter")
        print(f"üéØ {len(self.conflict_priorities)} conflits prioritaires")
    
    def _load_json_report(self, path: str) -> Dict:
        """Charge rapport JSON avec gestion erreurs"""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur chargement {path}: {e}")
            return {}
    
    def _extract_current_concepts(self) -> Dict[str, Dict]:
        """Extrait concepts actuels avec leurs d√©finitions"""
        concepts = {}
        
        # Depuis analyse ambigu√Øt√©s
        quality_analyses = self.ambiguity_data.get('quality_analyses', {})
        
        for concept_name, analysis in quality_analyses.items():
            if isinstance(analysis, dict):
                concepts[concept_name] = {
                    'atoms': analysis.get('atomic_decomposition', []),
                    'complexity': analysis.get('complexity_level', 0),
                    'validity': analysis.get('validity_score', 0.5),
                    'quality': analysis.get('description_quality', 'unknown'),
                    'issues': analysis.get('potential_issues', [])
                }
        
        return concepts
    
    def _extract_conflict_priorities(self) -> List[Dict]:
        """Extrait conflits avec priorit√©s du syst√®me d√©tection"""
        conflicts = self.detection_data.get('conflict_scores', [])
        
        # Filtrer conflits haute priorit√©
        high_priority = [
            c for c in conflicts 
            if c.get('resolution_type') in ['critical', 'high'] and 
               c.get('priority_score', 0) > 0.5
        ]
        
        return sorted(high_priority, key=lambda x: x.get('priority_score', 0), reverse=True)
    
    def _build_contextual_dimensions(self) -> Dict[str, Dict]:
        """Base de donn√©es dimensions contextuelles par domaine s√©mantique"""
        return {
            'emotions': {
                'AMOUR': {
                    'romantic': {'weight': 0.4, 'markers': ['passion', 'intimit√©', 'exclusivit√©']},
                    'familial': {'weight': 0.3, 'markers': ['protection', 'inconditionalit√©', 'permanence']},
                    'platonique': {'weight': 0.2, 'markers': ['admiration', 'respect', 'spiritualit√©']},
                    'universel': {'weight': 0.1, 'markers': ['compassion', 'humanit√©', 'altruisme']}
                },
                'JOIE': {
                    'euphoric': {'weight': 0.2, 'markers': ['extase', 'd√©bordement', 'temporaire']},
                    'contentement': {'weight': 0.4, 'markers': ['satisfaction', 's√©r√©nit√©', 'durable']},
                    'social': {'weight': 0.3, 'markers': ['partage', 'contagion', 'c√©l√©bration']},
                    'achievement': {'weight': 0.1, 'markers': ['fiert√©', 'accomplissement', 'm√©rite']}
                },
                'TRISTESSE': {
                    'melancholic': {'weight': 0.3, 'markers': ['nostalgie', 'po√©sie', 'douce-am√®re']},
                    'grief': {'weight': 0.4, 'markers': ['deuil', 'perte', 'profonde']},
                    'disappointment': {'weight': 0.2, 'markers': ['d√©ception', 'attente', 'temporaire']},
                    'existential': {'weight': 0.1, 'markers': ['vide', 'sens', 'm√©taphysique']}
                }
            },
            'arts': {
                'MUSIQUE': {
                    'performance': {'weight': 0.3, 'markers': ['ex√©cution', 'virtuosit√©', 'live']},
                    'composition': {'weight': 0.2, 'markers': ['cr√©ation', 'harmonie', 'structure']},
                    'reception': {'weight': 0.3, 'markers': ['√©coute', '√©motion', 'interpr√©tation']},
                    'cultural': {'weight': 0.2, 'markers': ['tradition', 'identit√©', 'social']}
                },
                'ART': {
                    'visual': {'weight': 0.4, 'markers': ['image', 'forme', 'couleur']},
                    'conceptual': {'weight': 0.2, 'markers': ['id√©e', 'concept', 'critique']},
                    'expressive': {'weight': 0.3, 'markers': ['√©motion', 'personnel', 'subjectif']},
                    'social': {'weight': 0.1, 'markers': ['soci√©t√©', 'politique', 'message']}
                }
            },
            'nature': {
                '√âTOILE': {
                    'astronomical': {'weight': 0.4, 'markers': ['cosmos', 'physique', 'distance']},
                    'navigational': {'weight': 0.2, 'markers': ['orientation', 'guide', 'reference']},
                    'symbolic': {'weight': 0.3, 'markers': ['destin', 'espoir', 'r√™ve']},
                    'mythological': {'weight': 0.1, 'markers': ['l√©gende', 'divinit√©', 'ancestral']}
                }
            }
        }
    
    def _build_connotative_profiles(self) -> Dict[str, Dict[str, float]]:
        """Profils connotatifs (valence √©motionnelle) par concept"""
        return {
            'AMOUR': {'positive': 0.8, 'intensity': 0.9, 'complexity': 0.7, 'universality': 0.8},
            'JOIE': {'positive': 0.9, 'intensity': 0.7, 'complexity': 0.3, 'universality': 0.9},
            'TRISTESSE': {'positive': 0.1, 'intensity': 0.6, 'complexity': 0.5, 'universality': 0.8},
            'MUSIQUE': {'positive': 0.7, 'intensity': 0.6, 'complexity': 0.8, 'universality': 0.9},
            '√âTOILE': {'positive': 0.6, 'intensity': 0.4, 'complexity': 0.6, 'universality': 0.7},
            'D√âGO√õT': {'positive': 0.1, 'intensity': 0.8, 'complexity': 0.4, 'universality': 0.6}
        }
    
    def _build_pragmatic_constraints(self) -> Dict[str, List[str]]:
        """Contraintes pragmatiques d'usage par concept"""
        return {
            'AMOUR': [
                'N√©cessite r√©ciprocit√© contextuelle',
                'Intensit√© variable selon relation', 
                'Aspectuel: peut √™tre processuel ou statique',
                'Culturellement variable dans expression'
            ],
            'MUSIQUE': [
                'N√©cessite support/medium',
                'Temporellement structur√©e',
                'Socialement partageable',
                'Techniquement produire'
            ],
            '√âTOILE': [
                'R√©f√©rence visuelle n√©cessaire',
                'Distance conceptuelle importante',
                'Usage m√©taphorique fr√©quent',
                'Contexte observation requis'
            ]
        }
    
    def process_high_priority_refinements(self) -> List[RefinedConcept]:
        """Traite raffinements haute priorit√©"""
        
        print(f"\nüéØ TRAITEMENT RAFFINEMENTS HAUTE PRIORIT√â")
        print("=" * 55)
        
        refined_concepts = []
        
        # Traiter top 20 conflits prioritaires
        top_conflicts = self.conflict_priorities[:20]
        
        for i, conflict in enumerate(top_conflicts):
            concept_name = self._extract_concept_from_conflict_id(conflict.get('conflict_id', ''))
            
            if not concept_name or concept_name not in self.current_concepts:
                continue
            
            print(f"\nüîß Raffinement {i+1}/20: {concept_name}")
            
            # Appliquer raffinement sp√©cialis√©
            refined_concept = self._refine_specific_concept(concept_name, conflict)
            
            if refined_concept:
                refined_concepts.append(refined_concept)
                print(f"   ‚úÖ Raffin√© (confiance: {refined_concept.confidence_score:.2f})")
            else:
                print(f"   ‚ùå √âchec raffinement")
        
        return refined_concepts
    
    def _extract_concept_from_conflict_id(self, conflict_id: str) -> str:
        """Extrait nom concept depuis ID conflit"""
        # Format: "incoherent_CONCEPT" ou "semantic_conflict_CONCEPT1_CONCEPT2"
        parts = conflict_id.split('_')
        if len(parts) >= 2:
            # Pour "incoherent_CONCEPT", retourner CONCEPT
            if parts[0] == 'incoherent' and len(parts) == 2:
                return parts[1]
            # Pour "semantic_conflict_X_Y", retourner le premier concept
            elif 'conflict' in conflict_id and len(parts) >= 3:
                return parts[-2]
            # Cas g√©n√©ral: dernier √©l√©ment
            else:
                return parts[-1]
        return ''
    
    def _refine_specific_concept(self, concept_name: str, conflict: Dict) -> Optional[RefinedConcept]:
        """Raffine concept sp√©cifique selon conflit d√©tect√©"""
        
        current_def = self.current_concepts.get(concept_name, {})
        current_atoms = current_def.get('atoms', [])
        
        # Raffinements sp√©cialis√©s par concept probl√©matique
        if concept_name == 'AMOUR':
            return self._refine_amour_concept(current_atoms, conflict)
        elif concept_name == 'MUSIQUE':
            return self._refine_musique_concept(current_atoms, conflict)
        elif concept_name == '√âTOILE':
            return self._refine_etoile_concept(current_atoms, conflict)
        elif concept_name == 'D√âGO√õT':
            return self._refine_degout_concept(current_atoms, conflict)
        else:
            # Raffinement g√©n√©rique
            return self._refine_generic_concept(concept_name, current_atoms, conflict)
    
    def _refine_amour_concept(self, current_atoms: List[str], conflict: Dict) -> RefinedConcept:
        """Raffinement sp√©cialis√© pour AMOUR"""
        
        # Nouvelles dimensions atomiques coh√©rentes
        refined_atoms = ['EMOTION', 'COMMUNICATION', 'POSSESSION', 'CREATION']
        
        # Dimensions contextuelles riches
        contextual_dims = self.contextual_dimensions_db['emotions']['AMOUR']
        
        return RefinedConcept(
            original_name='AMOUR',
            refined_atoms=refined_atoms,
            contextual_dimensions=contextual_dims,
            connotative_aspects=self.connotative_profiles_db['AMOUR'],
            pragmatic_constraints=self.pragmatic_constraints_db['AMOUR'],
            usage_patterns={
                'romantic': ['aimer passionn√©ment', '√™tre amoureux de', '√©prouver de l\'amour'],
                'familial': ['amour maternel', 'amour filial', 'amour fraternel'],
                'platonique': ['amour spirituel', 'amour pur', 'amour d√©sint√©ress√©'],
                'universel': ['amour de l\'humanit√©', 'amour universel', 'amour divin']
            },
            confidence_score=0.9,
            linguistic_justification="Remplacement DESTRUCTION par CREATION + ajout dimensions contextuelles multiples pour capturer richesse s√©mantique"
        )
    
    def _refine_musique_concept(self, current_atoms: List[str], conflict: Dict) -> RefinedConcept:
        """Raffinement sp√©cialis√© pour MUSIQUE"""
        
        refined_atoms = ['COMMUNICATION', 'CREATION', 'EMOTION', 'MOUVEMENT']
        contextual_dims = self.contextual_dimensions_db['arts']['MUSIQUE']
        
        return RefinedConcept(
            original_name='MUSIQUE',
            refined_atoms=refined_atoms,
            contextual_dimensions=contextual_dims,
            connotative_aspects=self.connotative_profiles_db['MUSIQUE'],
            pragmatic_constraints=self.pragmatic_constraints_db['MUSIQUE'],
            usage_patterns={
                'performance': ['jouer de la musique', 'interpr√©ter', 'ex√©cuter'],
                'composition': ['composer', 'cr√©er', 'arranger'],
                'reception': ['√©couter', 'appr√©cier', 'ressentir'],
                'cultural': ['tradition musicale', 'identit√© culturelle', 'patrimoine']
            },
            confidence_score=0.8,
            linguistic_justification="Ajout COMMUNICATION/CREATION/EMOTION pour capturer art complet vs DESTRUCTION/MOUVEMENT r√©ducteur"
        )
    
    def _refine_etoile_concept(self, current_atoms: List[str], conflict: Dict) -> RefinedConcept:
        """Raffinement sp√©cialis√© pour √âTOILE"""
        
        refined_atoms = ['EXISTENCE', 'PERCEPTION', 'MOUVEMENT']
        contextual_dims = self.contextual_dimensions_db['nature']['√âTOILE']
        
        return RefinedConcept(
            original_name='√âTOILE',
            refined_atoms=refined_atoms,
            contextual_dimensions=contextual_dims,
            connotative_aspects=self.connotative_profiles_db['√âTOILE'],
            pragmatic_constraints=self.pragmatic_constraints_db['√âTOILE'],
            usage_patterns={
                'astronomical': ['√©toile fixe', 'magnitude', 'constellation'],
                'navigational': ['√©toile polaire', 's\'orienter', 'navigation'],
                'symbolic': ['√©toile du destin', '√©toile filante', '√©toile de l\'espoir'],
                'mythological': ['√©toile des bergers', '√©toile du matin', 'vo√ªte c√©leste']
            },
            confidence_score=0.7,
            linguistic_justification="Ajout EXISTENCE/PERCEPTION/MOUVEMENT pour corps c√©leste vs COMMUNICATION seule inad√©quate"
        )
    
    def _refine_degout_concept(self, current_atoms: List[str], conflict: Dict) -> RefinedConcept:
        """Raffinement sp√©cialis√© pour D√âGO√õT"""
        
        refined_atoms = ['EMOTION', 'DESTRUCTION', 'PERCEPTION']
        
        return RefinedConcept(
            original_name='D√âGO√õT',
            refined_atoms=refined_atoms,
            contextual_dimensions={
                'physiological': {'weight': 0.4, 'markers': ['naus√©e', 'r√©pulsion', 'corporel']},
                'moral': {'weight': 0.3, 'markers': ['indignation', '√©thique', 'valeurs']},
                'aesthetic': {'weight': 0.2, 'markers': ['laideur', 'dysharmonie', 'go√ªt']},
                'social': {'weight': 0.1, 'markers': ['rejet', 'exclusion', 'norme']}
            },
            connotative_aspects=self.connotative_profiles_db['D√âGO√õT'],
            pragmatic_constraints=[
                'R√©action involontaire √† stimulus',
                'Gradable en intensit√©',
                'Peut √™tre culturellement conditionn√©',
                'Aspect protecteur √©volutionnaire'
            ],
            usage_patterns={
                'physiological': ['avoir des naus√©es', 'r√©pugner', '√©c≈ìurer'],
                'moral': ['√™tre indign√©', 'r√©prouver', 'condamner'],
                'aesthetic': ['trouver laid', 'd√©plaire', 'choquer'],
                'social': ['rejeter', 'm√©priser', 'exclure']
            },
            confidence_score=0.8,
            linguistic_justification="Ajout EMOTION/PERCEPTION pour capturer aspect r√©actionnel vs EXISTENCE seule insuffisante"
        )
    
    def _refine_generic_concept(self, concept_name: str, current_atoms: List[str], 
                               conflict: Dict) -> Optional[RefinedConcept]:
        """Raffinement g√©n√©rique pour concepts non sp√©cialis√©s"""
        
        # Strat√©gie g√©n√©rique: ajouter dimension contextuelle
        refined_atoms = current_atoms + ['CONTEXT'] if 'CONTEXT' not in current_atoms else current_atoms
        
        return RefinedConcept(
            original_name=concept_name,
            refined_atoms=refined_atoms,
            contextual_dimensions={'generic': {'weight': 1.0, 'markers': ['contextuel', 'variable']}},
            connotative_aspects={'neutral': 0.5},
            pragmatic_constraints=['N√©cessite sp√©cification contextuelle'],
            usage_patterns={'generic': [f'utilisation de {concept_name}']},
            confidence_score=0.4,
            linguistic_justification="Raffinement g√©n√©rique avec ajout dimension contextuelle"
        )
    
    def generate_refined_dictionary(self, refined_concepts: List[RefinedConcept]) -> Dict[str, Any]:
        """G√©n√®re dictionnaire raffin√© avec concepts am√©lior√©s"""
        
        print(f"\nüìö G√âN√âRATION DICTIONNAIRE RAFFIN√â")
        print("=" * 45)
        
        refined_dict = {
            'metadata': {
                'version': 'RAFFIN√â-v3.0',
                'timestamp': time.strftime("%Y-%m-%d %H:%M:%S"),
                'source_analysis': self.ambiguity_report_path,
                'refinement_count': len(refined_concepts),
                'methodology': 'ambiguity_resolution_with_contextual_enrichment'
            },
            'concepts_raffines': {},
            'operations_applied': [],
            'validation_tests': []
        }
        
        # Ajouter concepts raffin√©s
        for concept in refined_concepts:
            refined_dict['concepts_raffines'][concept.original_name] = asdict(concept)
        
        # Statistiques raffinement
        avg_confidence = np.mean([c.confidence_score for c in refined_concepts])
        print(f"üìä Concepts raffin√©s: {len(refined_concepts)}")
        print(f"üìä Confiance moyenne: {avg_confidence:.2f}")
        
        return refined_dict
    
    def run_complete_refinement_process(self) -> str:
        """Lance processus complet de raffinement"""
        
        print(f"\nüöÄ D√âMARRAGE PROCESSUS COMPLET RAFFINEMENT")
        print("=" * 60)
        
        start_time = time.time()
        
        try:
            # √âtape 1: Raffinements haute priorit√©
            refined_concepts = self.process_high_priority_refinements()
            
            # √âtape 2: G√©n√©ration dictionnaire raffin√©
            refined_dictionary = self.generate_refined_dictionary(refined_concepts)
            
            # √âtape 3: Sauvegarde
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            output_path = f"dictionnaire_raffine_{timestamp}.json"
            
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(refined_dictionary, f, ensure_ascii=False, indent=2)
            
            duration = time.time() - start_time
            
            print(f"\n‚úÖ RAFFINEMENT TERMIN√â")
            print(f"‚è±Ô∏è  Dur√©e: {duration:.1f}s")
            print(f"üíæ Dictionnaire raffin√©: {output_path}")
            print(f"üìä Concepts trait√©s: {len(refined_concepts)}")
            
            return output_path
            
        except Exception as e:
            print(f"‚ùå ERREUR RAFFINEMENT: {e}")
            import traceback
            traceback.print_exc()
            return ""

def main():
    """Lance processus raffinement d√©finitions"""
    import glob
    
    print("üîß D√âMARRAGE PROCESSUS RAFFINEMENT D√âFINITIONS")
    
    # Trouver rapports d'analyse
    ambiguity_reports = glob.glob("analyse_ambiguites_dictionnaire_*.json")
    detection_reports = glob.glob("rapport_detection_automatique_*.json")
    
    if not ambiguity_reports:
        print("‚ùå Aucun rapport d'ambigu√Øt√©s trouv√©")
        return
        
    if not detection_reports:
        print("‚ùå Aucun rapport de d√©tection trouv√©")  
        return
    
    latest_ambiguity = max(ambiguity_reports, key=os.path.getctime)
    latest_detection = max(detection_reports, key=os.path.getctime)
    
    print(f"üìÑ Rapport ambigu√Øt√©s: {latest_ambiguity}")
    print(f"üìÑ Rapport d√©tection: {latest_detection}")
    
    # Initialiser processeur
    processor = DefinitionRefinementProcessor(latest_ambiguity, latest_detection)
    
    # Lancer raffinement complet
    result_path = processor.run_complete_refinement_process()
    
    if result_path:
        print(f"\nüéØ SUCC√àS - Dictionnaire raffin√© disponible: {result_path}")
    else:
        print(f"\n‚ùå √âCHEC - Voir logs pour d√©tails")

if __name__ == "__main__":
    main()